<tool id="gatk4_ApplyVQSR" name="GATK4 ApplyVQSR" version="1.0.0">
    <description>- Apply a score cutoff to filter variants based on a recalibration table</description>
    <requirements>
      <requirement type="package" version="4.5.0.0">gatk4</requirement>
    </requirements>
    <macros>
      <import>macros.xml</import>
    </macros>

    <command detect_errors="exit_code">
        <![CDATA[
        ##Fix to run on arm macbook
        export JAVA_HOME=/Users/benjaminbeer/Downloads/jdk-17.0.10.jdk/Contents/Home/bin &&
        export PATH=/Users/benjaminbeer/Downloads/jdk-17.0.10.jdk/Contents/Home/bin:\$PATH &&


        #if str($tool_params.tool_param_selector) == "advanced"
            #set $reference_provided = False
            #if str($FASTA_TYPE.FASTA_TYPE_SELECTOR) == "uploaded"
                #if str($FASTA) != "None":
                ln -s "$FASTA" fasta.fa &&
                #set $reference_provided = True
             #end if
            #else
                #set $fasta_file = $fasta_source.fasta_id.fields.path
                ln -s "$fasta_file" fasta.fa &&
                #set $reference_provided = True
            #end if
            #if $reference_provided
                samtools faidx fasta.fa &&
                gatk CreateSequenceDictionary -R fasta.fa -O fasta.dict &&
            #end if
        #end if

        #for $i, $file in enumerate($variant_repeat):
            bgzip -c ${file.VCF} > '${i}.gz' &&
            tabix -p vcf '${i}.gz' &&
        #end for

        gatk ApplyVQSR --output '$output1' --recal-file '$recal_file'

        #for $i, $file in enumerate($variant_repeat):
            --variant '${i}.gz'
        #end for

        #if str($gatk_params.gatk_params_selector) == "advanced"
            ##Input Validation
            --read-validation-stringency "$read_validation_stringency"
            --disable-sequence-dictionary-validation '$disable_sequence_dictionary_validation'
            --lenient '$lenient'

            ##Genomic Intervals
            #for $i, $interval in enumerate($exclude_intervals_repeat):
                --exclude-intervals '${interval.XL}'
            #end for
            #if str($exclude_intervals_file) != "None"
                --exclude-intervals "$exclude_intervals_file"
            #end if
            --interval-exclusion-padding "$interval_exclusion_padding"
            --interval-set-rule "$interval_set_rule"

            ##Performance
            --use-jdk-deflater '$use_jdk_deflater'
            --use-jdk-inflater '$use_jdk_inflater'

            ##Macro Files
            #if str($gatk_config_file) != "None":
                --gatk-config-file "$gatk_config_file"
            #end if
            #if str($arguments_file) != "None":
                --arguments_file "$arguments_file"
            #end if
            #if str($sequence_dictionary) != "None":
                --sequence-dictionary "$sequence_dictionary"
            #end if
            #if str($read_index) != "None":
                --read-index "$read_index"
            #end if
        #end if

        #if str($tool_params.tool_param_selector) == "advanced"
            --mode '$mode'
            ##Inputs
            #if $reference_provided
                --reference fasta.fa
            #end if
            #if str($tranches_file) != "None":
                --tranches-file $tranches_file
            #end if

            ##Filtering
            --ignore-all-filters "$ignore_all_filters"
            #for $i, $item in enumerate($ignore_filter_repeat):
                --ignore-filter ${item.filter}
            #end for
            #if $truth_sensitivity_filter_level
                --truth-sensitivity-filter-level "$truth_sensitivity_filter_level"
            #end if
            #if $lod_score_cutoff
                --lod-score-cutoff "$lod_score_cutoff"
            #end if
            --use-allele-specific-annotations "$use_allele_specific_annotations"

            ## Read Filters
            --disable-tool-default-read-filters
            #for $filter in $tool_filters:
                --read-filter "$filter"
            #end for
            #if $AmbiguousBaseReadFilter:
                --read-filter "AmbiguousBaseReadFilter"
                #if $ambig_filter_frac
                    --ambig-filter-frac "$ambig_filter_frac"
                #else
                    --ambig-filter-bases "$ambig_filter_bases"
                #end if
            #end if

            #if $ExcessiveEndClippedReadFilter
                --read-filter "ExcessiveEndClippedReadFilter" 
                --max-clipped-bases "$max_clipped_bases"
            #end if

            #if $FlowBasedTPAttributeValidReadFilter
                --read-filter "FlowBasedTPAttributeValidReadFilter" 
                --read-filter-max-hmer "$read_filter_max_hmer"
            #end if

            #if $FragmentLengthReadFilter
                --read-filter "FragmentLengthReadFilter" 
                #if $max_fragment_length
                    --max-fragment-length "$max_fragment_length"
                #end if
                #if $min_fragment_length
                    --min-fragment-length "$min_fragment_length"
                #end if
            #end if

            #if $IntervalOverlapReadFilter
                --read-filter "IntervalOverlapReadFilter" 
                --keep-intervals "$keep_intervals"
            #end if

            #if $JexlExpressionReadTagValueFilter
                --read-filter "JexlExpressionReadTagValueFilter" 
                --read-filter-expression "$read_filter_expression"
            #end if

            #if $LibraryReadFilter
                --read-filter "LibraryReadFilter" 
                --library "$library"
            #end if

            #if $MappingQualityReadFilter
                --read-filter "MappingQualityReadFilter" 
                #if $minimum_mapping_quality
                    --minimum-mapping-quality "$minimum_mapping_quality"
                #end if
                #if $maximum_mapping_quality
                    --maximum-mapping-quality "$maximum_mapping_quality"
                #end if
            #end if

            #if $MateDistantReadFilter
                --read-filter "MateDistantReadFilter" 
                --mate-too-distant-length "$mate_too_distant_length"
            #end if

            #if $OverclippedReadFilter
                --read-filter "OverclippedReadFilter" 
                --filter-too-short "$filter_too_short"
                --dont-require-soft-clips-both-ends "$dont_require_soft_clips_both_ends"
            #end if

            #if $PlatformReadFilter
                --read-filter "PlatformReadFilter" 
                --platform-filter-name "$platform_filter_name"
            #end if

            #if $PlatformUnitReadFilter
                --read-filter "PlatformUnitReadFilter" 
                --black-listed-lanes "$black_listed_lanes"
            #end if

            #if $ReadGroupBlackListReadFilter
                --read-filter "ReadGroupBlackListReadFilter" 
                --read-group-black-list "$read_group_black_list"
            #end if

            #if $ReadGroupReadFilter
                --read-filter "ReadGroupReadFilter" 
                --keep-read-group "$keep_read_group"
            #end if

            #if $ReadLengthReadFilter
                --read-filter "ReadLengthReadFilter" 
                --max-read-length "$max_read_length"
                #if $min_read_length
                    --min-read-length "$min_read_length"
                #end if
            #end if

            #if $ReadNameReadFilter
                --read-filter "ReadNameReadFilter" 
                --read-name "$read_name"
            #end if

            #if $ReadStrandFilter
                --read-filter "ReadStrandFilter" 
                --keep-reverse-strand-only "$keep_reverse_strand_only"
            #end if

            #if $ReadTagValueFilter
                --read-filter "ReadTagValueFilter" 
                --read-filter-tag "$read_filter_tag"
                --read-filter-tag-comp "$read_filter_tag_comp"
            #end if

            #if $SampleReadFilter
                --read-filter "SampleReadFilter" 
                --sample "$sample"
            #end if

            #if $SoftClippedReadFilter:
                --read-filter "SoftClippedReadFilter"
                --invert-soft-clip-ratio-filter "$invert_soft_clip_ratio_filter"
                #if $soft_clipped_ratio_threshold
                    --soft-clipped-ratio-threshold "$soft_clipped_ratio_threshold"
                #else
                    --soft-clipped-leading-trailing-ratio "$soft_clipped_leading_trailing_ratio"
                #end if
            #end if

            ##Genomic Intervals
            #for $i, $interval in enumerate($intervals_repeat):
                --intervals '${interval.L}'
            #end for
            --interval-padding "$interval_padding"
            --interval-merging-rule "$interval_merging_rule"

            ##Penalties & Buffers
            --cloud-prefetch-buffer '$cloud_prefetch_buffer'
            #if $cloud_index_prefetch_buffer
                --cloud-index-prefetch-buffer '$cloud_index_prefetch_buffer'
            #end if

            ##Performance
            --gcs-max-retries "$gcs_max_retries"
            --disable-bam-index-caching "$disable_bam_index_caching"            
        #end if
        ]]>
    </command>
    <inputs>
        <repeat argument="--variant" name="variant_repeat" label="Variant files" help="A VCF file containing variants" default="1" >
              <param name="VCF" type="data" format="vcf" />
        </repeat>
        <param type="data" argument="--recal-file" label="Recalibration File" help="The input recal file used by ApplyRecalibration" />

        <expand macro="gatk_param_type_conditional" />

        <conditional name ="tool_params">
            <param name="tool_param_selector" type="select" label="Basic or Advanced Tool options">
            <option value="basic" selected="True">Basic</option>
            <option value="advanced">Advanced</option>
            </param>
            <when value="basic">
            <!--Do nothing-->
            </when>
            <when value="advanced">
                <param type="select" argument="--mode" label="Recalibration mode">
                    <option value="SNP" selected="True">SNP</option>
                    <option value="INDEL">INDEL</option>
                    <option value="BOTH">BOTH</option>
                </param>
                <section name="Inputs"> 
                <!-- Find format -->
                    <conditional name="FASTA_TYPE"> 
                        <param name="FASTA_TYPE_SELECTOR" type="select" label="Reference File" >
                            <option value="uploaded" selected="True">Uploaded</option>
                            <option value="galaxy">Galaxy</option>
                        </param>
                        <when value="uploaded">
                            <param type="data" argument="--reference" name="FASTA" format="fasta" label="Reference file" optional="True" />
                        </when>
                        <when value="galaxy">
                        <param argument="--reference" type="select" label="Select reference genome" help="If your genome of interest is not listed, contact the Galaxy team" optional="True">
                            <options from_data_table="fasta_indexes" />
                        </param>
                        </when>
                    </conditional>
                    <param type="data" argument="--tranches-file" label="Tranches file to cut the data" optional="True" />
                </section>
                <section name="Filtering">
                    <param type="boolean" argument="--ignore-all-filters" label="Ignore all input filters" checked="False" /> A
                    <repeat argument="--ignore-filter" label="Ignore Filter" name="ignore_filter_repeat">
                      <param type="text" name="filter" label="Filter to ignore" />
                    </repeat>
                    <param type="float" argument="--truth-sensitivity-filter-level" label="Truth sensitivity level to start filtering" optional="True" />
                    <param type="float" argument="--lod-score-cutoff" label="VQSLOD score below which to filter" optional="True" />
                    <param type="boolean" argument="--use-allele-specific-annotations" label="Filter each allele based on input tranches and alle-specific .recal file" checked="False" />
                </section>
                <section name="Read Filters">
                    <param name="tool_filters" type="select" multiple="True" display="checkboxes" label="Default read filters"  >
                    <option value="AlignmentAgreesWithHeaderReadFilter" selected="False" />
                    <option value="AllowAllReadsReadFilter" selected="False" />
                    <option value="CigarContainsNoNOperator" selected="False" />
                    <option value="FirstOfPairReadFilter" selected="False" />
                    <option value="FlowBasedTPAttributeSymetricReadFilter" selected="False" />
                    <option value="GoodCigarReadFilter" selected="False" />
                    <option value="HasReadGroupReadFilter" selected="False" />
                    <option value="HmerQualitySymetricReadFilter" selected="False" />
                    <option value="MappedReadFilter" selected="False" />
                    <option value="MappingQualityAvailableReadFilter" selected="False" />
                    <option value="MappingQualityNotZeroReadFilter" selected="False" />
                    <option value="MatchingBasesAndQualsReadFilter" selected="False" />
                    <option value="MateDifferentStrandReadFilter" selected="False" />
                    <option value="MateOnSameContigOrNoMappedMateReadFilter" selected="False" />   
                    <option value="MateUnmappedAndUnmappedReadFilter" selected="False" />
                    <option value="MetricsReadFilter" selected="False" />
                    <option value="NonChimericOriginalAlignmentReadFilter" selected="False" />
                    <option value="NonZeroFragmentLengthReadFilter" selected="False" />
                    <option value="NonZeroReferenceLengthAlignmentReadFilter" selected="False" />
                    <option value="NotDuplicateReadFilter" selected="False" />
                    <option value="NotProperlyPairedReadFilter" selected="False" />
                    <option value="NotSecondaryAlignmentReadFilter" selected="False" />   
                    <option value="NotSupplementaryAlignmentReadFilter" selected="False" />
                    <option value="PairedReadFilter" selected="False" />
                    <option value="PassesVendorQualityCheckReadFilter" selected="False" />
                    <option value="PrimaryLineReadFilter" selected="False" />
                    <option value="ProperlyPairedReadFilter" selected="False" />   
                    <option value="ReadGroupHasFlowOrderReadFilter" selected="False" />
                    <option value="ReadLengthEqualsCigarLengthReadFilter" selected="False" />
                    <option value="SecondOfPairReadFilter" selected="False" />
                    <option value="SeqIsStoredReadFilter" selected="False" />
                    <option value="ValidAlignmentEndReadFilter" selected="False" />
                    <option value="ValidAlignmentStartReadFilter" selected="False" />
                    <option value="WellformedFlowBasedReadFilter" selected="False" />
                    <option value="WellformedReadFilter" selected="False" />   
                    
                    <!-- Sets the tool default read filters to True (Update when run) -->
                    </param>
                    <conditional name="AmbiguousBaseReadFilter">
                        <param type="boolean" name="AmbiguousBaseReadFilter" truevalue="Yes" falsevalue="No" label="Ambiguous Base Read Filter" />
                        <when value="Yes">
                            <param type="float" argument="--ambig-filter-frac" value="0.5" optional="True"/>
                            <param type="integer" argument="--ambig-filter-bases" optional="True"/>
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="ExcessiveEndClippedReadFilter">
                        <param type="boolean" name="ExcessiveEndClippedReadFilter" truevalue="Yes" falsevalue="No" label="Excessive End Clipped Read Filter" />
                        <when value="Yes">
                            <param type="integer" argument="--max-clipped-bases" value="1000" />
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="FlowBasedTPAttributeValidReadFilter">
                        <param type="boolean" name="FlowBasedTPAttributeValidReadFilter" truevalue="Yes" falsevalue="No" label="Flow Based TP Attribute Valid Read Filter" />
                        <when value="Yes">
                            <param type="integer" argument="--read-filter-max-hmer" value="12" />
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="FragmentLengthReadFilter">
                        <param type="boolean" name="FragmentLengthReadFilter" truevalue="Yes" falsevalue="No" label="Fragment Length Read Filter" />
                        <when value="Yes">
                            <param type="integer" argument="--max-fragment-length" value="1000000" />
                            <param type="integer" argument="--min-fragment-length" value="0" />
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="IntervalOverlapReadFilter">
                        <param type="boolean" name="IntervalOverlapReadFilter" truevalue="Yes" falsevalue="No" label="Interval Overlap Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--keep-intervals" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="JexlExpressionReadTagValueFilter">
                        <param type="boolean" name="JexlExpressionReadTagValueFilter" truevalue="Yes" falsevalue="No" label="Jexl Expression Read Tag Value Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-filter-expression" help="One or more JEXL expressions used to filter"/>
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="LibraryReadFilter">
                        <param type="boolean" name="LibraryReadFilter" truevalue="Yes" falsevalue="No" label="Library Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--library" help="Name of the library to keep"/>
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="MappingQualityReadFilter">
                        <param type="boolean" name="MappingQualityReadFilter" truevalue="Yes" falsevalue="No" label="Mapping Quality Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--minimum-mapping-quality" value="10" optional="True" />
                                <param type="integer" argument="--maximum-mapping-quality" optional="True" />                            
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="MateDistantReadFilter">
                        <param type="boolean" name="MateDistantReadFilter" truevalue="Yes" falsevalue="No" label="Mate Distant Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--mate-too-distant-length" value="1000" />                    
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="OverclippedReadFilter">
                        <param type="boolean" name="OverclippedReadFilter" truevalue="Yes" falsevalue="No" label="Overclipped Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--filter-too-short" value="30" />   
                                <param type="boolean" argument="--dont-require-soft-clips-both-ends" checked="False" />                 
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="PlatformReadFilter">
                        <param type="boolean" name="PlatformReadFilter" truevalue="Yes" falsevalue="No" label="Platform Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--platform-filter-name" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="PlatformUnitReadFilter">
                        <param type="boolean" name="PlatformUnitReadFilter" truevalue="Yes" falsevalue="No" label="Platform Unit Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--black-listed-lanes" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadGroupBlackListReadFilter">
                        <param type="boolean" name="ReadGroupBlackListReadFilter" truevalue="Yes" falsevalue="No" label="Read Group BlackList Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-group-black-list" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadGroupReadFilter">
                        <param type="boolean" name="ReadGroupReadFilter" truevalue="Yes" falsevalue="No" label="Read Group Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--keep-read-group" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadLengthReadFilter">
                        <param type="boolean" name="ReadLengthReadFilter" truevalue="Yes" falsevalue="No" label="Read Length Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--max-read-length" />  
                                <param type="integer" argument="--min-read-length" value="1" optional="True" />                          
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadNameReadFilter">
                        <param type="boolean" name="ReadNameReadFilter" truevalue="Yes" falsevalue="No" label="Read Name Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-name" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadStrandFilter">
                        <param type="boolean" name="ReadStrandFilter" truevalue="Yes" falsevalue="No" label="Read Strand Filter" />
                            <when value="Yes">
                                <param type="boolean" argument="--keep-reverse-strand-only" checked="False" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadTagValueFilter">
                        <param type="boolean" name="ReadTagValueFilter" truevalue="Yes" falsevalue="No" label="Read Tag Value Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-filter-tag" />
                                <param type="float" argument="--read-filter-tag-comp" value="0.0" />
                                <param type="select" argument="--read-filter-tag-op" label="Read Filter Tag Operator">
                                    <option value="EQUAL" selected="True">EQUAL</option>
                                    <option value="NOT_EQUAL">NOT_EQUAL</option>
                                    <option value="LESS">LESS</option>
                                    <option value="LESS_OR_EQUAL">LESS_OR_EQUAL</option>
                                    <option value="GREATER">GREATER</option>
                                    <option value="GREATER_OR_EQUAL">GREATER_OR_EQUAL</option>
                                </param>
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="SampleReadFilter">
                        <param type="boolean" name="SampleReadFilter" truevalue="Yes" falsevalue="No" label="Sample Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--sample" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="SoftClippedReadFilter">
                        <param type="boolean" name="SoftClippedReadFilter" truevalue="Yes" falsevalue="No" label="Soft ClippedRead Filter" />
                            <when value="Yes">
                                <param type="boolean" argument="--invert-soft-clip-ratio-filter" checked="False" />
                                <param type="float" argument="--soft-clipped-ratio-threshold" optional="True" />
                                <param type="float" argument="--soft-clipped-leading-trailing-ratio" optional="True" />                            
                            </when>
                            <when value="No" />
                    </conditional>
                </section>
                <section name="Genomic Intervals">
                    <repeat argument="--intervals" name="intervals_repeat" label="Genomic interval over which to operate" help="-L">
                        <param name="L" type="text" value="" />
                    </repeat>
                    <param type="integer" argument="--interval-padding" label="Amount of padding for each interval (bp)" value="0" help="For example, '-L 1:100' with a padding value of 20 would turn into '-L 1:80-120'."/>
                    <param type="select" argument="--interval-merging-rule" label="Rule for merging abutting intervals">
                        <option value="ALL" selected="True">ALL</option>
                        <option value="OVERLAPPING_ONLY">OVERLAPPING_ONLY</option>
                    </param>
                </section>
                <section name="Penalties &amp; Buffers">
                    <param type="integer" argument="--cloud-prefetch-buffer" label="Size of the cloud-only prefetch buffer (in MB)" value="40" help="0 to disable." />
                    <param type="integer" argument="--cloud-index-prefetch-buffer" label="Size of the cloud-only prefetch buffer (in MB)" optional="True" help="Defaults to cloudPrefetchBuffer" />
                </section>
                <section name="Performance">
                    <param type="integer" argument="--gcs-max-retries" label="Number of times to attempt to re-initiate connection to GCS bucket channel" value="20" />
                    <param type="boolean" argument="--disable-bam-index-caching" label="Cache bam indexes (reduces memory requirements)" checked="True" />
                </section>
            </when>
        </conditional>
      </inputs>
      <outputs>
        xz c x<data argument="--output" name="output1" type="data" format="vcf" label="Annotated VCF" />
      </outputs>
    <tests>
    </tests>

    <help>
      **What it does**

      Apply a score cutoff to filter variants based on a recalibration table
      This tool performs the second pass in a two-stage process called Variant Quality Score Recalibration (VQSR). Specifically, it applies filtering to the input variants based on the recalibration table produced in the first step by VariantRecalibrator and a target sensitivity value, which the tool matches internally to a VQSLOD score cutoff based on the model's estimated sensitivity to a set of true variants.

      The filter determination is not just a pass/fail process. The tool evaluates for each variant which "tranche", or slice of the dataset, it falls into in terms of sensitivity to the truthset. Variants in tranches that fall below the specified truth sensitivity filter level have their FILTER field annotated with the corresponding tranche level. This results in a callset that is filtered to the desired level but retains the information necessary to increase sensitivity if needed.

      To be clear, please note that by "filtered", we mean that variants failing the requested tranche cutoff are marked as filtered in the output VCF; they are not discarded unless the option to do so is specified.

      https://gatk.broadinstitute.org/hc/en-us/articles/5358890204187-ApplyVQSR

    </help>

</tool>