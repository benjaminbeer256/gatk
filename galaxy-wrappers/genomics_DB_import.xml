<tool id="gatk4_GenomicsDBImport" name="GATK4 GenomicsDBImport" version="1.0.0">
    <description>- Import VCFs to GenomicsDB</description>
    <requirements>
      <requirement type="package" version="4.2.6.1">gatk4</requirement>
    </requirements>
    <macros>
        <import>macros.xml</import>
    </macros>
    <command detect_errors="exit_code">
        <![CDATA[
        ##Fix to run on arm macbook
        export JAVA_HOME=/Users/benjaminbeer/Downloads/jdk-17.0.10.jdk/Contents/Home/bin &&
        export PATH=/Users/benjaminbeer/Downloads/jdk-17.0.10.jdk/Contents/Home/bin:\$PATH &&

        #if str($tool_params.tool_param_selector) == "advanced"
            #set $reference_provided = False
            #if str($FASTA_TYPE.FASTA_TYPE_SELECTOR) == "uploaded"
                #if str($FASTA) != "None":
                    ln -s "$FASTA" fasta.fa &&
                    #set $reference_provided = True
            #else
                #set $fasta_file = $fasta_source.fasta_id.fields.path
                ln -s "$fasta_file" fasta.fa &&
                #set $reference_provided = True
            #end if
            #if $reference_provided
                samtools faidx fasta.fa &&
                gatk CreateSequenceDictionary -R fasta.fa -O fasta.dict &&
            #end if
        #end if

        #if $GVCF_conditional.GVCF_selector == "Individually"
            #for $i, $file in enumerate($variant_repeat):
                bgzip -c ${file.GVCF} > '${i}.gz' &&
                tabix -p vcf '${i}.gz' &&
            #end for
            gatk GenomicsDBImport
            #for $i, $file in enumerate($variant_repeat):
                --variant '${i}.gz' 
            #end for
        #else
            gatk GenomicsDBImport --sample-name-map '$variants'
        #end if

        #for $i, $interval in enumerate($intervals_repeat):
            --intervals '${interval.L}'
        #end for

        #if str($gatk_params.gatk_params_selector) == "advanced"
            ##Input Validation
            --read-validation-stringency "$read_validation_stringency"
            --disable-sequence-dictionary-validation '$disable_sequence_dictionary_validation'
            --lenient '$lenient'

            ##Genomic Intervals
            #for $i, $interval in enumerate($exclude_intervals_repeat):
                --exclude-intervals '${interval.XL}'
            #end for
            #if str($exclude_intervals_file) != "None"
                --exclude-intervals "$exclude_intervals_file"
            #end if
            --interval-exclusion-padding "$interval_exclusion_padding"
            --interval-set-rule "$interval_set_rule"

            ##Performance
            --use-jdk-deflater '$use_jdk_deflater'
            --use-jdk-inflater '$use_jdk_inflater'

            ##Macro Files
            #if str($gatk_config_file) != "None":
                --gatk-config-file "$gatk_config_file"
            #end if
            #if str($arguments_file) != "None":
                --arguments_file "$arguments_file"
            #end if
            #if str($sequence_dictionary) != "None":
                --sequence-dictionary "$sequence_dictionary"
            #end if
            #if str($read_index) != "None":
                --read-index "$read_index"
            #end if
        #end if


    #if str($tool_params.tool_param_selector) == "advanced"
        ##Inputs & Validation
        #if $reference_provided
            --reference "fasta.fa"
        #end if
        --validate-sample-name-map "$validate_sample_name_map"
        --disable-sequence-dictionary-validation "$disable_sequence_dictionary_validation"

        ##Read Filters
        --disable-tool-default-read-filters
        #for $filter in $tool_filters:
            --read-filter "$filter"
        #end for
        #if $AmbiguousBaseReadFilter:
            --read-filter "AmbiguousBaseReadFilter"
            #if $ambig_filter_frac
                --ambig-filter-frac "$ambig_filter_frac"
            #else
                --ambig-filter-bases "$ambig_filter_bases"
            #end if
        #end if
        #if $ExcessiveEndClippedReadFilter
            --read-filter "ExcessiveEndClippedReadFilter" 
            --max-clipped-bases "$max_clipped_bases"
        #end if
        #if $FlowBasedTPAttributeValidReadFilter
            --read-filter "FlowBasedTPAttributeValidReadFilter" 
            --read-filter-max-hmer "$read_filter_max_hmer"
        #end if
        #if $FragmentLengthReadFilter
            --read-filter "FragmentLengthReadFilter" 
            #if $max_fragment_length
                --max-fragment-length "$max_fragment_length"
            #end if
            #if $min_fragment_length
                --min-fragment-length "$min_fragment_length"
            #end if
        #end if
        #if $IntervalOverlapReadFilter
            --read-filter "IntervalOverlapReadFilter" 
            --keep-intervals "$keep_intervals"
        #end if
        #if $JexlExpressionReadTagValueFilter
            --read-filter "JexlExpressionReadTagValueFilter" 
            --read-filter-expression "$read_filter_expression"
        #end if
        #if $LibraryReadFilter
            --read-filter "LibraryReadFilter" 
            --library "$library"
        #end if
        #if $MappingQualityReadFilter
            --read-filter "MappingQualityReadFilter" 
            #if $minimum_mapping_quality
                --minimum-mapping-quality "$minimum_mapping_quality"
            #end if
            #if $maximum_mapping_quality
                --maximum-mapping-quality "$maximum_mapping_quality"
            #end if
        #end if
        #if $MateDistantReadFilter
            --read-filter "MateDistantReadFilter" 
            --mate-too-distant-length "$mate_too_distant_length"
        #end if
        #if $OverclippedReadFilter
            --read-filter "OverclippedReadFilter" 
            --filter-too-short "$filter_too_short"
            --dont-require-soft-clips-both-ends "$dont_require_soft_clips_both_ends"
        #end if
        #if $PlatformReadFilter
            --read-filter "PlatformReadFilter" 
            --platform-filter-name "$platform_filter_name"
        #end if
        #if $PlatformUnitReadFilter
            --read-filter "PlatformUnitReadFilter" 
            --black-listed-lanes "$black_listed_lanes"
        #end if
        #if $ReadGroupBlackListReadFilter
            --read-filter "ReadGroupBlackListReadFilter" 
            --read-group-black-list "$read_group_black_list"
        #end if
        #if $ReadGroupReadFilter
            --read-filter "ReadGroupReadFilter" 
            --keep-read-group "$keep_read_group"
        #end if
        #if $ReadLengthReadFilter
            --read-filter "ReadLengthReadFilter" 
            --max-read-length "$max_read_length"
            #if $min_read_length
                --min-read-length "$min_read_length"
            #end if
        #end if
        #if $ReadNameReadFilter
            --read-filter "ReadNameReadFilter" 
            --read-name "$read_name"
        #end if
        #if $ReadStrandFilter
            --read-filter "ReadStrandFilter" 
            --keep-reverse-strand-only "$keep_reverse_strand_only"
        #end if
        #if $ReadTagValueFilter
            --read-filter "ReadTagValueFilter" 
            --read-filter-tag "$read_filter_tag"
            --read-filter-tag-comp "$read_filter_tag_comp"
        #end if
        #if $SampleReadFilter
            --read-filter "SampleReadFilter" 
            --sample "$sample"
        #end if
        #if $SoftClippedReadFilter:
            --read-filter "SoftClippedReadFilter"
            --invert-soft-clip-ratio-filter "$invert_soft_clip_ratio_filter"
            #if $soft_clipped_ratio_threshold
                --soft-clipped-ratio-threshold "$soft_clipped_ratio_threshold"
            #else
                --soft-clipped-leading-trailing-ratio "$soft_clipped_leading_trailing_ratio"
            #end if
        #end if

        ##Genomic Intervals
        --interval-merging-rule "$interval_merging_rule"

        ##Penalties & Buffers
        --cloud-prefetch-buffer "$cloud_prefetch_buffer"
        #if $cloud_index_prefetch_buffer
            --cloud-index-prefetch-buffer "$cloud_index_prefetch_buffer"
        #end if

        ##Performance
        --batch-size "$batch_size"
        --gcs-max-retries "$gcs_max_retries"
        --genomicsdb-segment-size "$genomicsdb_segment_size"
        --genomicsdb-vcf-buffer-size "$genomicsdb_vcf_buffer_size"
        --max-num-intervals-to-import-in-parallel "$max_num_intervals_to_import_in_parallel"
        --reader-threads "$reader_threads"
        --consolidate "$consolidate"
        --disable-bam-index-caching "$disable_bam_index_caching"

        ##Outputs
        --sites-only-vcf-output "$sites_only_vcf_output"
        #if $gcs_project_for_requester_pays
            --gcs-project-for-requester-pays "$gcs_project_for_requester_pays"
        #end if
    #end if
    --genomicsdb-workspace-path genomics_db_out &&

    zip -r out.zip genomics_db_out &&
    cp out.zip '$output1'
        ]]>
    </command>
    <inputs>
        <conditional name="GVCF_conditional">
            <param name="GVCF_selector" type="select" label="Variants" >
                <option value="Individually" selected="True">Individually</option>
                <option value="Map">Map</option>
            </param>
        <when value="Individually">
            <repeat argument="--variant" name="variant_repeat" title="GVCF files to be imported to GenomicsDB" help="Each file must contain data for only a single sample." default="1" >
                <param name="GVCF" type="data" format="vcf" />
            </repeat>      
        </when>
        <when value="Map">
          <param type="data" name="variants" format="sample_map" label="Map of GVCFs" />
        </when>
      </conditional>    
      <repeat argument="--intervals" name="intervals_repeat" title="genomic interval over which to operate" help="-L" default="1">
            <param name="L" type="text" value=""/>
        </repeat>        

      <expand macro="gatk_param_type_conditional" />


      <conditional name ="tool_params">
      <param name="tool_param_selector" type="select" label="Basic or Advanced Tool options">
      <option value="basic" selected="True">Basic</option>
      <option value="advanced">Advanced</option>
      </param>
      <when value = "basic">
          <!--Do nothing-->
      </when>
      <when value="advanced">
        <section name="Inputs &amp; Validation">
          <conditional name="FASTA_TYPE">
            <param name="FASTA_TYPE_SELECTOR" type="select" label="Number of files containing known sites" >
                <option value="uploaded" selected="True">Uploaded</option>
                <option value="galaxy">Galaxy</option>
            </param>
            <when value="File">
                <param type="data" argument="--reference" format="fasta" label="Reference file"/>
            </when>
            <when value="From Galaxy">
              <param argument="--reference" type="select" label="Select reference genome" help="If your genome of interest is not listed, contact the Galaxy team" optional="True">
                  <options from_data_table="fasta_indexes" />
              </param>
            </when>
          </conditional>
          <param type="boolean" argument="--validate-sample-name-map" label="Enable checks on the sampleNameMap file" checked="False" />
          <param type="boolean" argument="--disable-sequence-dictionary-validation" label="Validate inputs with sequence dictionaries" checked="True" help="Disable at your own risk!" />
        </section>
        <section name="Read Filters">
            <param name="tool_filters" type="select" multiple="True" display="checkboxes" label="Default read filters"  >
                <option value="AlignmentAgreesWithHeaderReadFilter" selected="False" />
                <option value="AllowAllReadsReadFilter" selected="False" />
                <option value="CigarContainsNoNOperator" selected="False" />
                <option value="FirstOfPairReadFilter" selected="False" />
                <option value="FlowBasedTPAttributeSymetricReadFilter" selected="False" />
                <option value="GoodCigarReadFilter" selected="False" />
                <option value="HasReadGroupReadFilter" selected="False" />
                <option value="HmerQualitySymetricReadFilter" selected="False" />
                <option value="MappedReadFilter" selected="False" />
                <option value="MappingQualityAvailableReadFilter" selected="False" />
                <option value="MappingQualityNotZeroReadFilter" selected="False" />
                <option value="MatchingBasesAndQualsReadFilter" selected="False" />
                <option value="MateDifferentStrandReadFilter" selected="False" />
                <option value="MateOnSameContigOrNoMappedMateReadFilter" selected="False" />   
                <option value="MateUnmappedAndUnmappedReadFilter" selected="False" />
                <option value="MetricsReadFilter" selected="False" />
                <option value="NonChimericOriginalAlignmentReadFilter" selected="False" />
                <option value="NonZeroFragmentLengthReadFilter" selected="False" />
                <option value="NonZeroReferenceLengthAlignmentReadFilter" selected="False" />
                <option value="NotDuplicateReadFilter" selected="False" />
                <option value="NotProperlyPairedReadFilter" selected="False" />
                <option value="NotSecondaryAlignmentReadFilter" selected="False" />   
                <option value="NotSupplementaryAlignmentReadFilter" selected="False" />
                <option value="PairedReadFilter" selected="False" />
                <option value="PassesVendorQualityCheckReadFilter" selected="False" />
                <option value="PrimaryLineReadFilter" selected="False" />
                <option value="ProperlyPairedReadFilter" selected="False" />   
                <option value="ReadGroupHasFlowOrderReadFilter" selected="False" />
                <option value="ReadLengthEqualsCigarLengthReadFilter" selected="False" />
                <option value="SecondOfPairReadFilter" selected="False" />
                <option value="SeqIsStoredReadFilter" selected="False" />
                <option value="ValidAlignmentEndReadFilter" selected="False" />
                <option value="ValidAlignmentStartReadFilter" selected="False" />
                <option value="WellformedFlowBasedReadFilter" selected="False" />
                <option value="WellformedReadFilter" selected="False" />   
                
                <!-- Sets the tool default read filters to True (No default read filters?) -->
            </param>
            <conditional name="AmbiguousBaseReadFilter">
                <param type="boolean" name="AmbiguousBaseReadFilter" truevalue="Yes" falsevalue="No" label="Ambiguous Base Read Filter" />
                <when value="Yes">
                    <param type="float" argument="--ambig-filter-frac" value="0.5" optional="True"/>
                    <param type="integer" argument="--ambig-filter-bases" optional="True"/>
                </when>
                <when value="No" />
            </conditional>
            <conditional name="ExcessiveEndClippedReadFilter">
                <param type="boolean" name="ExcessiveEndClippedReadFilter" truevalue="Yes" falsevalue="No" label="Excessive End Clipped Read Filter" />
                <when value="Yes">
                    <param type="integer" argument="--max-clipped-bases" value="1000" />
                </when>
                <when value="No" />
            </conditional>
            <conditional name="FlowBasedTPAttributeValidReadFilter">
                <param type="boolean" name="FlowBasedTPAttributeValidReadFilter" truevalue="Yes" falsevalue="No" label="Flow Based TP Attribute Valid Read Filter" />
                <when value="Yes">
                    <param type="integer" argument="--read-filter-max-hmer" value="12" />
                </when>
                <when value="No" />
            </conditional>
            <conditional name="FragmentLengthReadFilter">
                <param type="boolean" name="FragmentLengthReadFilter" truevalue="Yes" falsevalue="No" label="Fragment Length Read Filter" />
                <when value="Yes">
                    <param type="integer" argument="--max-fragment-length" value="1000000" />
                    <param type="integer" argument="--min-fragment-length" value="0" />
                </when>
                <when value="No" />
            </conditional>
            <conditional name="IntervalOverlapReadFilter">
                <param type="boolean" name="IntervalOverlapReadFilter" truevalue="Yes" falsevalue="No" label="Interval Overlap Read Filter" />
                    <when value="Yes">
                        <param type="text" argument="--keep-intervals" />
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="JexlExpressionReadTagValueFilter">
                <param type="boolean" name="JexlExpressionReadTagValueFilter" truevalue="Yes" falsevalue="No" label="Jexl Expression Read Tag Value Filter" />
                    <when value="Yes">
                        <param type="text" argument="--read-filter-expression" help="One or more JEXL expressions used to filter"/>
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="LibraryReadFilter">
                <param type="boolean" name="LibraryReadFilter" truevalue="Yes" falsevalue="No" label="Library Read Filter" />
                    <when value="Yes">
                        <param type="text" argument="--library" help="Name of the library to keep"/>
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="MappingQualityReadFilter">
                <param type="boolean" name="MappingQualityReadFilter" truevalue="Yes" falsevalue="No" label="Mapping Quality Read Filter" />
                    <when value="Yes">
                        <param type="integer" argument="--minimum-mapping-quality" value="10" optional="True" />
                        <param type="integer" argument="--maximum-mapping-quality" optional="True" />                            
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="MateDistantReadFilter">
                <param type="boolean" name="MateDistantReadFilter" truevalue="Yes" falsevalue="No" label="Mate Distant Read Filter" />
                    <when value="Yes">
                        <param type="integer" argument="--mate-too-distant-length" value="1000" />                    
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="OverclippedReadFilter">
                <param type="boolean" name="OverclippedReadFilter" truevalue="Yes" falsevalue="No" label="Overclipped Read Filter" />
                    <when value="Yes">
                        <param type="integer" argument="--filter-too-short" value="30" />   
                        <param type="boolean" argument="--dont-require-soft-clips-both-ends" checked="False" />                 
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="PlatformReadFilter">
                <param type="boolean" name="PlatformReadFilter" truevalue="Yes" falsevalue="No" label="Platform Read Filter" />
                    <when value="Yes">
                        <param type="text" argument="--platform-filter-name" />
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="PlatformUnitReadFilter">
                <param type="boolean" name="PlatformUnitReadFilter" truevalue="Yes" falsevalue="No" label="Platform Unit Read Filter" />
                    <when value="Yes">
                        <param type="text" argument="--black-listed-lanes" />
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="ReadGroupBlackListReadFilter">
                <param type="boolean" name="ReadGroupBlackListReadFilter" truevalue="Yes" falsevalue="No" label="Read Group BlackList Read Filter" />
                    <when value="Yes">
                        <param type="text" argument="--read-group-black-list" />
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="ReadGroupReadFilter">
                <param type="boolean" name="ReadGroupReadFilter" truevalue="Yes" falsevalue="No" label="Read Group Read Filter" />
                    <when value="Yes">
                        <param type="text" argument="--keep-read-group" />
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="ReadLengthReadFilter">
                <param type="boolean" name="ReadLengthReadFilter" truevalue="Yes" falsevalue="No" label="Read Length Read Filter" />
                    <when value="Yes">
                        <param type="integer" argument="--max-read-length" />  
                        <param type="integer" argument="--min-read-length" value="1" optional="True" />                          
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="ReadNameReadFilter">
                <param type="boolean" name="ReadNameReadFilter" truevalue="Yes" falsevalue="No" label="Read Name Read Filter" />
                    <when value="Yes">
                        <param type="text" argument="--read-name" />
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="ReadStrandFilter">
                <param type="boolean" name="ReadStrandFilter" truevalue="Yes" falsevalue="No" label="Read Strand Filter" />
                    <when value="Yes">
                        <param type="boolean" argument="--keep-reverse-strand-only" checked="False" />
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="ReadTagValueFilter">
                <param type="boolean" name="ReadTagValueFilter" truevalue="Yes" falsevalue="No" label="Read Tag Value Filter" />
                    <when value="Yes">
                        <param type="text" argument="--read-filter-tag" />
                        <param type="float" argument="--read-filter-tag-comp" value="0.0" />
                        <param type="select" argument="--read-filter-tag-op" label="Read Filter Tag Operator">
                            <option value="EQUAL" selected="True">EQUAL</option>
                            <option value="NOT_EQUAL">NOT_EQUAL</option>
                            <option value="LESS">LESS</option>
                            <option value="LESS_OR_EQUAL">LESS_OR_EQUAL</option>
                            <option value="GREATER">GREATER</option>
                            <option value="GREATER_OR_EQUAL">GREATER_OR_EQUAL</option>
                        </param>
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="SampleReadFilter">
                <param type="boolean" name="SampleReadFilter" truevalue="Yes" falsevalue="No" label="Sample Read Filter" />
                    <when value="Yes">
                        <param type="text" argument="--sample" />
                    </when>
                    <when value="No" />
            </conditional>
            <conditional name="SoftClippedReadFilter">
                <param type="boolean" name="SoftClippedReadFilter" truevalue="Yes" falsevalue="No" label="Soft ClippedRead Filter" />
                    <when value="Yes">
                        <param type="boolean" argument="--invert-soft-clip-ratio-filter" checked="False" />
                        <param type="float" argument="--soft-clipped-ratio-threshold" optional="True" />
                        <param type="float" argument="--soft-clipped-leading-trailing-ratio" optional="True" />                            
                    </when>
                    <when value="No" />
            </conditional>
        </section>
        <section name="Genomic Intervals">
            <param type="select" argument="--interval-merging-rule" label="Rule for merging abutting intervals">
                <option value="ALL" selected="True">ALL</option>
                <option value="OVERLAPPING_ONLY">OVERLAPPING_ONLY</option>
            </param>
        </section>
        <section name="Penalties &amp; Buffers">
            <param type="integer" argument="--cloud-prefetch-buffer" label="Size of the cloud-only prefetch buffer (in MB)" value="40" help="0 to disable." />
            <param type="integer" argument="--cloud-index-prefetch-buffer" label="Size of the cloud-only prefetch buffer (in MB)" optional="True" help="Defaults to cloudPrefetchBuffer" />
        </section>
        <section name="Performance">
            <param type="integer" argument="--batch-size" label="Number of samples that are open at once" value="0" />
            <param type="integer" argument="--gcs-max-retries" value="20" label="Number of times to attempt to re-initiate connection to GCS bucket channel" />
            <!-- Check if segment/buffer should be long -->
            <param type="integer" argument="--genomicsdb-segment-size" label="Buffer size allocated for GenomicsDB (bytes)" value="1048576" />
            <param type="integer" argument="--genomicsdb-vcf-buffer-size" label="Buffer size for storing variant contexts (bytes)" value="16384" />
            <param type="integer" argument="--max-num-intervals-to-import-in-parallel" label="Max number of intervals to import in parallel" />
            <param type="integer" argument="--reader-threads" label="Number of simultaneous threads to use when opening VCFs in batches" />
            <param type="boolean" argument="--consolidate" label="Merge all fragments into one" checked="False" />
            <param type="boolean" argument="--disable-bam-index-caching" label="Cache bam indexes (reduces memory requirements)" checked="True" />
        </section>
        <section name="Outputs amp; Payment">
            <param type="boolean" argument="--sites-only-vcf-output" label="Don't emit genotype fields when writing vcf file" checked="False" />
            <param type="text" argument="--gcs-project-for-requester-pays" label="Project to bill when accessing requester pays buckets" optional="True" />
        </section>
        </when>
    </conditional>

          <!-- 
        Omitted:
        -overwrite-existing-genomicsdb-workspace

        -create-output-bam-index, 
        -create-output-bam-md5, 
        -preserve-qscores-less-than,
        -create-output-variant-index, 
        -create-output-variant-md5 
        -QUIET
        -seconds-between-progress-updates
        -TMP_DIR
        -->

    </inputs>
    <outputs>
        <data name="output1" format="zip" label="Compressed Database"/>
    </outputs>

    <tests>
    </tests>

    <help>
      **What it does**

      Import single-sample GVCFs into GenomicsDB before joint genotyping.
      The GATK4 Best Practice Workflow for SNP and Indel calling uses GenomicsDBImport to merge GVCFs from multiple samples. GenomicsDBImport offers the same functionality as CombineGVCFs and initially came from the Intel-Broad Center for Genomics. The datastore transposes sample-centric variant information across genomic loci to make data more accessible to tools.

      To query the contents of the GenomicsDB datastore, use SelectVariants. See Tutorial#11813 to get started.

      Details on GenomicsDB are at https://github.com/GenomicsDB/GenomicsDB/wiki. In brief, GenomicsDB utilises a data storage system optimized for storing/querying sparse arrays. Genomics data is typically sparse in that each sample has few variants with respect to the entire reference genome. GenomicsDB contains specialized code for genomics applications, such as VCF parsing and INFO field annotation calculation.

      https://gatk.broadinstitute.org/hc/en-us/articles/5358869876891-GenomicsDBImport

    </help>

</tool>