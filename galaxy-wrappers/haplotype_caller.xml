<tool id="gatk4_HaplotypeCaller" name="GATK4 HaplotypeCaller" version="1.0.0">
    <description>- Call germline SNPs and indels via local re-assembly of haplotypes</description>
    <requirements>
        <requirement type="package" version="4.5.0.0">gatk4</requirement>
    </requirements>
    <macros>
        <import>macros.xml</import>
    </macros>
    <command detect_errors="exit_code">
    <![CDATA[
    ln -s "$BAM" bamfile.bam &&
    ln -s "$OUTPUT" output.vcf &&

    #if str($FASTA_TYPE.FASTA_TYPE_SELECTOR) == "uploaded"
        ln -s "$FASTA" fasta.fa &&
    #else
        #set $fasta_file = $fasta_source.fasta_id.fields.path
        ln -s "$fasta_file" fasta.fa &&
    #end if

    samtools faidx fasta.fa --output fasta.fa.fai &&
    gatk CreateSequenceDictionary -R fasta.fa -O fasta.dict &&

    gatk BuildBamIndex -I bamfile.bam &&

    gatk HaplotypeCaller -I bamfile.bam -R fasta.fa -O output.vcf

    #if str($gatk_params.gatk_params_selector) == "advanced"
        ##Input Validation
        --read-validation-stringency "$read_validation_stringency"
        --disable-sequence-dictionary-validation "$disable_sequence_dictionary_validation"
        --lenient "$lenient"

        ##Genomic Intervals
        #for $i, $interval in enumerate($exclude_intervals_repeat):
            --exclude-intervals "${interval.XL}"
        #end for
        #if str($exclude_intervals_file) != "None"
            --exclude-intervals "$exclude_intervals_file"
        #end if
        --interval-exclusion-padding "$interval_exclusion_padding"
        --interval-set-rule "$interval_set_rule"

        ##Performance
        --use-jdk-deflater "$use_jdk_deflater"
        --use-jdk-inflater "$use_jdk_inflater"

        ##Macro Files
        #if str($gatk_config_file) != "None":
            --gatk-config-file "$gatk_config_file"
        #end if
        #if str($arguments_file) != "None":
            --arguments_file "$arguments_file"
        #end if
        #if str($sequence_dictionary) != "None":
            --sequence-dictionary "$sequence_dictionary"
        #end if
        #if str($read_index) != "None":
            --read-index "$read_index"
        #end if
    #end if

    #if str($tool_params.tool_param_selector) == "advanced"
        ## Population Options
        #if str($pedigree) != "None":
            --pedigree "$pedigree"
        #end if
        #if str($population_callset) != "None":
            --population-callset "$population_callset"
        #end if
        #if $founder_id:
            --founder-id "$founder_id"
        #end if
        --sample-ploidy "$sample_ploidy"
        --heterozygosity "$heterozygosity"
        --heterozygosity-stdev "$heterozygosity_stdev"
        --indel-heterozygosity "$indel_heterozygosity"

        ## Variant Calling   
        #if str($dbsnp) != "None":
            --dbsnp "$dbsnp"
        #end if
        --standard-min-confidence-threshold-for-calling "$standard_min_confidence_threshold_for_calling"

        ## Read Filters
        --disable-tool-default-read-filters
        #for $filter in $tool_filters:
            --read-filter "$filter"
        #end for

        #if $AmbiguousBaseReadFilter:
            --read-filter "AmbiguousBaseReadFilter"
            #if $ambig_filter_frac
                --ambig-filter-frac "$ambig_filter_frac"
            #else
                --ambig-filter-bases "$ambig_filter_bases"
            #end if
        #end if

        #if $ExcessiveEndClippedReadFilter
            --read-filter "ExcessiveEndClippedReadFilter" 
            --max-clipped-bases "$max_clipped_bases"
        #end if

        #if $FlowBasedTPAttributeValidReadFilter
            --read-filter "FlowBasedTPAttributeValidReadFilter" 
            --read-filter-max-hmer "$read_filter_max_hmer"
        #end if

        #if $FragmentLengthReadFilter
            --read-filter "FragmentLengthReadFilter" 
            #if $max_fragment_length
                --max-fragment-length "$max_fragment_length"
            #end if
            #if $min_fragment_length
                --min-fragment-length "$min_fragment_length"
            #end if
        #end if

        #if $IntervalOverlapReadFilter
            --read-filter "IntervalOverlapReadFilter" 
            --keep-intervals "$keep_intervals"
        #end if

        #if $JexlExpressionReadTagValueFilter
            --read-filter "JexlExpressionReadTagValueFilter" 
            --read-filter-expression "$read_filter_expression"
        #end if

        #if $LibraryReadFilter
            --read-filter "LibraryReadFilter" 
            --library "$library"
        #end if

        #if $MappingQualityReadFilter
            --read-filter "MappingQualityReadFilter" 
            #if $minimum_mapping_quality
                --minimum-mapping-quality "$minimum_mapping_quality"
            #end if
            #if $maximum_mapping_quality
                --maximum-mapping-quality "$maximum_mapping_quality"
            #end if
        #end if

        #if $MateDistantReadFilter
            --read-filter "MateDistantReadFilter" 
            --mate-too-distant-length "$mate_too_distant_length"
        #end if

        #if $OverclippedReadFilter
            --read-filter "OverclippedReadFilter" 
            --filter-too-short "$filter_too_short"
            --dont-require-soft-clips-both-ends "$dont_require_soft_clips_both_ends"
        #end if

        #if $PlatformReadFilter
            --read-filter "PlatformReadFilter" 
            --platform-filter-name "$platform_filter_name"
        #end if

        #if $PlatformUnitReadFilter
            --read-filter "PlatformUnitReadFilter" 
            --black-listed-lanes "$black_listed_lanes"
        #end if

        #if $ReadGroupBlackListReadFilter
            --read-filter "ReadGroupBlackListReadFilter" 
            --read-group-black-list "$read_group_black_list"
        #end if

        #if $ReadGroupReadFilter
            --read-filter "ReadGroupReadFilter" 
            --keep-read-group "$keep_read_group"
        #end if

        #if $ReadLengthReadFilter
            --read-filter "ReadLengthReadFilter" 
            --max-read-length "$max_read_length"
            #if $min_read_length
                --min-read-length "$min_read_length"
            #end if
        #end if

        #if $ReadNameReadFilter
            --read-filter "ReadNameReadFilter" 
            --read-name "$read_name"
        #end if

        #if $ReadStrandFilter
            --read-filter "ReadStrandFilter" 
            --keep-reverse-strand-only "$keep_reverse_strand_only"
        #end if

        #if $ReadTagValueFilter
            --read-filter "ReadTagValueFilter" 
            --read-filter-tag "$read_filter_tag"
            --read-filter-tag-comp "$read_filter_tag_comp"
        #end if

        #if $SampleReadFilter
            --read-filter "SampleReadFilter" 
            --sample "$sample"
        #end if

        #if $SoftClippedReadFilter:
            --read-filter "SoftClippedReadFilter"
            --invert-soft-clip-ratio-filter "$invert_soft_clip_ratio_filter"
            #if $soft_clipped_ratio_threshold
                --soft-clipped-ratio-threshold "$soft_clipped_ratio_threshold"
            #else
                --soft-clipped-leading-trailing-ratio "$soft_clipped_leading_trailing_ratio"
            #end if
        #end if

        ## Genomic Intervals
        #for $interval in $intervals_repeat:
            --intervals ${interval.L}
        #end for
        --interval-padding "$interval_padding"
        --interval-merging-rule "$interval_merging_rule"

        ## Penalties & Buffers
        --cloud-prefetch-buffer "$cloud_prefetch_buffer"
        #if $cloud_index_prefetch_buffer
            --cloud-index-prefetch-buffer "$cloud_index_prefetch_buffer"
        #end if

        ## Alleles
        #if str($alleles) != "None":
            --alleles "$alleles"
        #end if
        #for $annotation in $annotations_repeat:
            --annotations ${annotation.A}
        #end for
        #for $group in $group_repeat:
            --annotation-group ${group.G}
        #end for
        #for $annotation in $exclude_annotations_repeat:
            --annotations-to-exclude ${annotation.AX}
        #end for
        --annotate-with-num-discovered-alleles "$annotate_with_num_discovered_alleles"
        --contamination-fraction-to-filter "$contamination_fraction_to_filter"
        --num-reference-samples-if-no-call "$num_reference_samples_if_no_call"

        ## Read Qualities and Filtering
        #if $sample_name
            --sample-name "$sample_name"
        #end if
        --max-reads-per-alignment-start "$max_reads_per_alignment_start"
        --base-quality-score-threshold "$base_quality_score_threshold"
        --min-base-quality-score "$min_base_quality_score"

        ## Performance
        --native-pair-hmm-threads "$native_pair_hmm_threads"
        --native-pair-hmm-use-double-precision "$native_pair_hmm_use_double_precision"
        --gcs-max-retries "$gcs_max_retries"
        --disable-bam-index-caching "$disable_bam_index_caching"

        ## Outputs
        --output-mode "$output_mode"
        --sites-only-vcf-output "$sites_only_vcf_output"
        #if $assembly_region_out
            --assembly-region-out "$ASSEMBLY_REGION_OUTPUT"
        #end if
    #end if

    #if str($advanced_tool_params.advanced_tool_param_selector) == "advanced"
        ##Boolean
        --adaptive-pruning "$adaptive_pruning"
        --all-site-pls "$all_site_pls"
        --allow-non-unique-kmers-in-ref "$allow_non_unique_kmers_in_ref"
        --debug-assembly "$debug_assembly"
        --disable-optimizations "$disable_optimizations"
        --disable-tool-default-annotations "$disable_tool_default_annotations"
        --do-not-run-physical-phasing "$do_not_run_physical_phasing"
        --dont-increase-kmer-sizes-for-cycles "$dont_increase_kmer_sizes_for_cycles"
        --dont-use-soft-clipped-bases "$dont_use_soft_clipped_bases"
        --enable-all-annotations "$enable_all_annotations"
        --floor-blocks "$floor_blocks"
        --force-active "$force_active"
        --force-call-filtered-alleles "$force_call_filtered_alleles"
        --recover-all-dangling-branches "$recover_all_dangling_branches"
        --use-filtered-reads-for-annotations "$use_filtered_reads_for_annotations"
        ##Integers
        --indel-size-to-eliminate-in-ref-model "$indel_size_to_eliminate_in_ref_model"
        --assembly-region-padding "$assembly_region_padding"
        --max-alternate-alleles "$max_alternate_alleles"
        --max-assembly-region-size "$max_assembly_region_size"
        --max-genotype-count "$max_genotype_count"
        --max-mnp-distance "$max_mnp_distance"
        --max-num-haplotypes-in-population "$max_num_haplotypes_in_population"
        --max-prob-propagation-distance "$max_prob_propagation_distance"
        --max-unpruned-variants "$max_unpruned_variants"
        --min-assembly-region-size "$min_assembly_region_size"
        --min-dangling-branch-length "$min_dangling_branch_length"
        --min-pruning "$min_pruning"
        --num-pruning-samples "$num_pruning_samples"
        --pair-hmm-gap-continuation-penalty "$pair_hmm_gap_continuation_penalty"
        --phred-scaled-global-read-mismapping-rate "$phred_scaled_global_read_mismapping_rate"
        --pruning-lod-threshold "$pruning_lod_threshold"
        --active-probability-threshold "$active_probability_threshold"
        --adaptive-pruning-initial-error-rate "$adaptive_pruning_initial_error_rate"

        ##Text
        #set $kmer_list = $kmer_size.replace("[", "").replace("]", "").replace(" ", "").split(",")
        #for $kmer in $kmer_list:
            --kmer-size "$kmer"
        #end for
        #set $bands = $gvcf_gq_bands.replace("[", "").replace("]", "").replace(" ", "").split(",")
        #for $band in $bands:
            --gvcf-gq-bands "$band"
        #end for

        ##Repeats
        #for $i, $file in enumerate($comparison_repeat):
            --exclude-intervals "${file.vcf}"
        #end for
        #for $i, $float in enumerate($prior_repeat):
            --exclude-intervals "${float.prior}"
        #end for

        ##Enum
        --emit-ref-confidence "$emit_ref_confidence"
        --pair-hmm-implementation "$pair_hmm_implementation"
        --pcr-indel-model "$pcr_indel_model"
        --smith-waterman "$smith_waterman"
    #end if
    ]]>
    </command>
    <inputs>
        <param name="BAM" type="data" format="bam,cram,sam" label="Input file" />
        <conditional name ="FASTA_TYPE">
            <param name="FASTA_TYPE_SELECTOR" type="select" label="Reference File">
            <option value="uploaded" selected="True">Uploaded</option>
            <option value="galaxy">Galaxy</option>
            </param>
            <when value = "uploaded">
                <param name="FASTA" type="data" format="fasta" label="Reference file"/>
            </when>
            <when value="galaxy">
                <param name="FASTA_SELECT" type="select" label="Select reference genome" help="If your genome of interest is not listed, contact the Galaxy team">
                    <options from_data_table="fasta_indexes" />
                </param>
            </when>
        </conditional>

        <expand macro="gatk_param_type_conditional" />

        <conditional name ="tool_params">
            <param name="tool_param_selector" type="select" label="Basic or Advanced Tool options">
                <option value="basic" selected="True">Basic</option>
                <option value="advanced">Advanced</option>
            </param>
            <when value = "basic">
                <!-- Do nothing -->
            </when>
            <when value="advanced">
            <section name="Population Options" help="See the GATKDocs for full details on the meaning of heterozygosity">
                <param type="data" argument="--pedigree" label="Pedigree file for determining the population founders" optional="True" />
                <param type="data" format="vcf" argument="--population-callset" label="Callset for calculating genotype priors" optional="True" help="Supporting external panel. Allele counts from this panel (taken from AC,AN or MLEAC,AN or raw genotypes) will be used to inform the frequency distribution underlying the genotype priors." />
                <param type="text" argument="--founder-id" label="Founder ID" help="Samples representing the population founders" />
                <param type="integer" argument="--sample-ploidy" label="Ploidy (number of chromosomes) per sample" value="2" help="For pooled data, set to (Number of samples in each pool * Sample Ploidy)."/>
                <param type="float" argument="--heterozygosity" label="Heterozygosity" value="0.001" help="The expected heterozygosity value used to compute prior probability that a locus is non-reference." />
                <param type="float" argument="--heterozygosity-stdev" label="Heterozygosity Standard Deviation" value="0.01" help="Standard deviation of heterozygosity for SNP and indel calling." />
                <param type="float" argument="--indel-heterozygosity" label="Indel Heterozygosity" value="0.000125" help="Informs the prior probability of having an indel at a site." />
            </section>
            <section name="Variant Calling">
                <param type="data" format="vcf" argument="--dbsnp" label="dbSNP" help="A dbSNP VCF file" optional="True" />
                <param type="float" argument="--standard-min-confidence-threshold-for-calling" label="The minimum phred-scaled confidence for calling variants" value="30.0" />
            </section>
            <section name="Read Filters">
                    <param name="tool_filters" type="select" multiple="True" display="checkboxes" label="Default read filters"  >
                        <option value="AlignmentAgreesWithHeaderReadFilter" selected="False" />
                        <option value="AllowAllReadsReadFilter" selected="False" />
                        <option value="CigarContainsNoNOperator" selected="False" />
                        <option value="FirstOfPairReadFilter" selected="False" />
                        <option value="FlowBasedTPAttributeSymetricReadFilter" selected="False" />
                        <option value="GoodCigarReadFilter" selected="False" />
                        <option value="HasReadGroupReadFilter" selected="False" />
                        <option value="HmerQualitySymetricReadFilter" selected="False" />
                        <option value="MappedReadFilter" selected="False" />
                        <option value="MappingQualityAvailableReadFilter" selected="False" />
                        <option value="MappingQualityNotZeroReadFilter" selected="False" />
                        <option value="MatchingBasesAndQualsReadFilter" selected="False" />
                        <option value="MateDifferentStrandReadFilter" selected="False" />
                        <option value="MateOnSameContigOrNoMappedMateReadFilter" selected="False" />   
                        <option value="MateUnmappedAndUnmappedReadFilter" selected="False" />
                        <option value="MetricsReadFilter" selected="False" />
                        <option value="NonChimericOriginalAlignmentReadFilter" selected="False" />
                        <option value="NonZeroFragmentLengthReadFilter" selected="False" />
                        <option value="NonZeroReferenceLengthAlignmentReadFilter" selected="False" />
                        <option value="NotDuplicateReadFilter" selected="False" />
                        <option value="NotProperlyPairedReadFilter" selected="False" />
                        <option value="NotSecondaryAlignmentReadFilter" selected="False" />   
                        <option value="NotSupplementaryAlignmentReadFilter" selected="False" />
                        <option value="PairedReadFilter" selected="False" />
                        <option value="PassesVendorQualityCheckReadFilter" selected="False" />
                        <option value="PrimaryLineReadFilter" selected="False" />
                        <option value="ProperlyPairedReadFilter" selected="False" />   
                        <option value="ReadGroupHasFlowOrderReadFilter" selected="False" />
                        <option value="ReadLengthEqualsCigarLengthReadFilter" selected="False" />
                        <option value="SecondOfPairReadFilter" selected="False" />
                        <option value="SeqIsStoredReadFilter" selected="False" />
                        <option value="ValidAlignmentEndReadFilter" selected="False" />
                        <option value="ValidAlignmentStartReadFilter" selected="False" />
                        <option value="WellformedFlowBasedReadFilter" selected="False" />
                        <option value="WellformedReadFilter" selected="False" />   
                        
                        <!-- Sets the tool default read filters to True -->
                        <option value="NotSecondaryAlignmentReadFilter" selected="True"/>
                        <option value="GoodCigarReadFilter" selected="True"/>
                        <option value="NonZeroReferenceLengthAlignmentReadFilter" selected="True"/>
                        <option value="PassesVendorQualityCheckReadFilter" selected="True"/>
                        <option value="MappedReadFilter" selected="True"/>
                        <option value="MappingQualityAvailableReadFilter" selected="True"/>
                        <option value="NotDuplicateReadFilter" selected="True"/>
                        <option value="MappingQualityReadFilter" selected="True"/>
                        <option value="WellformedReadFilter" selected="True"/>
                    </param>
                    <conditional name="AmbiguousBaseReadFilter">
                        <param type="boolean" name="AmbiguousBaseReadFilter" truevalue="Yes" falsevalue="No" label="Ambiguous Base Read Filter" />
                        <when value="Yes">
                            <param type="float" argument="--ambig-filter-frac" value="0.5" optional="True"/>
                            <param type="integer" argument="--ambig-filter-bases" optional="True"/>
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="ExcessiveEndClippedReadFilter">
                        <param type="boolean" name="ExcessiveEndClippedReadFilter" truevalue="Yes" falsevalue="No" label="Excessive End Clipped Read Filter" />
                        <when value="Yes">
                            <param type="integer" argument="--max-clipped-bases" value="1000" />
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="FlowBasedTPAttributeValidReadFilter">
                        <param type="boolean" name="FlowBasedTPAttributeValidReadFilter" truevalue="Yes" falsevalue="No" label="Flow Based TP Attribute Valid Read Filter" />
                        <when value="Yes">
                            <param type="integer" argument="--read-filter-max-hmer" value="12" />
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="FragmentLengthReadFilter">
                        <param type="boolean" name="FragmentLengthReadFilter" truevalue="Yes" falsevalue="No" label="Fragment Length Read Filter" />
                        <when value="Yes">
                            <param type="integer" argument="--max-fragment-length" value="1000000" />
                            <param type="integer" argument="--min-fragment-length" value="0" />
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="IntervalOverlapReadFilter">
                        <param type="boolean" name="IntervalOverlapReadFilter" truevalue="Yes" falsevalue="No" label="Interval Overlap Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--keep-intervals" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="JexlExpressionReadTagValueFilter">
                        <param type="boolean" name="JexlExpressionReadTagValueFilter" truevalue="Yes" falsevalue="No" label="Jexl Expression Read Tag Value Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-filter-expression" help="One or more JEXL expressions used to filter"/>
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="LibraryReadFilter">
                        <param type="boolean" name="LibraryReadFilter" truevalue="Yes" falsevalue="No" label="Library Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--library" help="Name of the library to keep"/>
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="MappingQualityReadFilter">
                        <param type="boolean" name="MappingQualityReadFilter" truevalue="Yes" falsevalue="No" label="Mapping Quality Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--minimum-mapping-quality" value="10" optional="True" />
                                <param type="integer" argument="--maximum-mapping-quality" optional="True" />                            
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="MateDistantReadFilter">
                        <param type="boolean" name="MateDistantReadFilter" truevalue="Yes" falsevalue="No" label="Mate Distant Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--mate-too-distant-length" value="1000" />                    
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="OverclippedReadFilter">
                        <param type="boolean" name="OverclippedReadFilter" truevalue="Yes" falsevalue="No" label="Overclipped Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--filter-too-short" value="30" />   
                                <param type="boolean" argument="--dont-require-soft-clips-both-ends" checked="False" />                 
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="PlatformReadFilter">
                        <param type="boolean" name="PlatformReadFilter" truevalue="Yes" falsevalue="No" label="Platform Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--platform-filter-name" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="PlatformUnitReadFilter">
                        <param type="boolean" name="PlatformUnitReadFilter" truevalue="Yes" falsevalue="No" label="Platform Unit Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--black-listed-lanes" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadGroupBlackListReadFilter">
                        <param type="boolean" name="ReadGroupBlackListReadFilter" truevalue="Yes" falsevalue="No" label="Read Group BlackList Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-group-black-list" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadGroupReadFilter">
                        <param type="boolean" name="ReadGroupReadFilter" truevalue="Yes" falsevalue="No" label="Read Group Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--keep-read-group" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadLengthReadFilter">
                        <param type="boolean" name="ReadLengthReadFilter" truevalue="Yes" falsevalue="No" label="Read Length Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--max-read-length" />  
                                <param type="integer" argument="--min-read-length" value="1" optional="True" />                          
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadNameReadFilter">
                        <param type="boolean" name="ReadNameReadFilter" truevalue="Yes" falsevalue="No" label="Read Name Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-name" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadStrandFilter">
                        <param type="boolean" name="ReadStrandFilter" truevalue="Yes" falsevalue="No" label="Read Strand Filter" />
                            <when value="Yes">
                                <param type="boolean" argument="--keep-reverse-strand-only" checked="False" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadTagValueFilter">
                        <param type="boolean" name="ReadTagValueFilter" truevalue="Yes" falsevalue="No" label="Read Tag Value Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-filter-tag" />
                                <param type="float" argument="--read-filter-tag-comp" value="0.0" />
                                <param type="select" argument="--read-filter-tag-op" label="Read Filter Tag Operator">
                                    <option value="EQUAL" selected="True">EQUAL</option>
                                    <option value="NOT_EQUAL">NOT_EQUAL</option>
                                    <option value="LESS">LESS</option>
                                    <option value="LESS_OR_EQUAL">LESS_OR_EQUAL</option>
                                    <option value="GREATER">GREATER</option>
                                    <option value="GREATER_OR_EQUAL">GREATER_OR_EQUAL</option>
                                </param>
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="SampleReadFilter">
                        <param type="boolean" name="SampleReadFilter" truevalue="Yes" falsevalue="No" label="Sample Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--sample" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="SoftClippedReadFilter">
                        <param type="boolean" name="SoftClippedReadFilter" truevalue="Yes" falsevalue="No" label="Soft ClippedRead Filter" />
                            <when value="Yes">
                                <param type="boolean" argument="--invert-soft-clip-ratio-filter" checked="False" />
                                <param type="float" argument="--soft-clipped-ratio-threshold" optional="True" />
                                <param type="float" argument="--soft-clipped-leading-trailing-ratio" optional="True" />                            
                            </when>
                            <when value="No" />
                    </conditional>
                </section>
                <section name="Genomic Intervals">
                    <repeat argument="--intervals" name="intervals_repeat" label="Genomic interval over which to operate" help="-L">
                        <param name="L" type="text" value=""/>
                    </repeat>                    
                    <param type="integer" argument="--interval-padding" label="Amount of padding for each interval (bp)" value="0" help="For example, "-L 1:100" with a padding value of 20 would turn into "-L 1:80-120"."/>
                    <param type="select" argument="--interval-merging-rule" label="Rule for merging abutting intervals">
                        <option value="ALL" selected="True">ALL</option>
                        <option value="OVERLAPPING_ONLY">OVERLAPPING_ONLY</option>
                    </param>
                </section>
                <section name="Penalties and Buffers">
                    <param type="integer" argument="--cloud-prefetch-buffer" label="Size of the cloud-only prefetch buffer (in MB)" value="40" help="0 to disable." />
                    <param type="integer" argument="--cloud-index-prefetch-buffer" label="Size of the cloud-only prefetch buffer (in MB)" optional="True" help="Defaults to cloudPrefetchBuffer" />
                </section>
                <section name="Alleles">
                    <param type="data" format="vcf" argument="--alleles" label="Set of alleles to force-call called regardless of evidence" optional="True" />
                    <repeat argument="--annotations"  name="annotations_repeat" label="Annotations to add to variant calls" help="These supplement annotations provided by annotation groups.">
                        <param name="A" type="text" value=""/>
                    </repeat>
                    <repeat argument="--annotation-group" name="group_repeat" label="Annotation groups to add to variant calls" help="Any requirements not met may cause run to fail. -G" optional="True">
                        <param name="G" type="text" value=""/>
                    </repeat>
                    <repeat argument="--annotations-to-exclude" name="exclude_annotations_repeat" label="Annotations to exclude from variant calls" help="This  has higher priority than the -A or -G arguments. -AX" optional="True">
                        <param name="AX" type="text" value=""/>
                    </repeat>
                    <param type="boolean" argument="--annotate-with-num-discovered-alleles" label="Annotate records with the number of alternate alleles that were discovered" checked="False" />
                    <param type="float" argument="--contamination-fraction-to-filter" label="Fraction of contamination to aggressively remove" value="0.0" help="If the pileup contains N total bases, then we will try to remove (N * contamination fraction) bases for each alternate allele." />
                    <param type="integer" argument="--num-reference-samples-if-no-call" label="Number of hom-ref genotypes to infer at sites" value="0" help="When a variant is not seen in any panel, this argument controls whether to infer (and with what effective strength) that only reference alleles were observed at that site."/>
                </section>
                <section name="Read Qualities and Filtering">
                    <param type="text" argument="--sample-name" label="Name of single sample from a multi-sample bam" optional="True" help="Use this argument to specify that HC should process a single sample out of a multisample BAM file."/>
                    <param type="integer" argument="--max-reads-per-alignment-start" label="Maximum number of reads per alignment start position" value="50" help="Set to 0 to disable." />
                    <param type="integer" argument="--base-quality-score-threshold" label="Base Quality Score Threshold" value="18" help="Base qualities below this threshold will be reduced to the minimum (6)" />
                    <param type="integer" argument="--min-base-quality-score" label="Minimum base quality required for calling" value="10" />
                    <param type="boolean" argument="--correct-overlapping-quality" label="Correct Overlapping Quality" checked="False" />
                </section>
                <section name="Performance">
                    <param type="integer" argument="--native-pair-hmm-threads" label="Threads for pairHMM to use" value="4" />
                    <param type="boolean" argument="--native-pair-hmm-use-double-precision" checked="False" />
                    <param type="integer" argument="--gcs-max-retries" value="20" label="Number of times to attempt to re-initiate connection to GCS bucket channel" />
                    <param type="boolean" argument="--disable-bam-index-caching" label="Disable BAM index caching bam indexes" checked="False" />
                </section>
                <section name="Outputs">
                    <param type="select" argument="--output-mode" label="Which type of calls we should output">
                        <option value="EMIT_VARIANTS_ONLY" selected="True">EMIT VARIANTS ONLY</option>
                        <option value="EMIT_ALL_CONFIDENT_SITES">EMIT ALL CONFIDENT SITES</option>
                        <option value="EMIT_ALL_ACTIVE_SITES">EMIT ALL ACTIVE SITES</option>
                    </param>
                    <param type="boolean" argument="--sites-only-vcf-output" label="Don"t emit genotype fields when writing vcf" checked="False"/>
                    <param type="boolean" argument="--assembly-region-out" label="Output assembly regions" checked="False" />
                    <param type="boolean" argument="--bam-output" label="Output bam file" />
                    <param type="select" argument="--bam-writer-type" label="Haplotypes written to bam">
                        <option value="CALLED_HAPLOTYPES" selected="true">CALLED_HAPLOTYPES</option>
                        <option value="ALL_POSSIBLE_HAPLOTYPES">ALL_POSSIBLE_HAPLOTYPES</option>
                    </param>
                </section>
            </when>
        </conditional>

        <conditional name ="advanced_tool_params">
            <param name="advanced_tool_param_selector" type="select" label="Basic or Advanced Tool options">
                <option value="basic" selected="True">Basic</option>
                <option value="advanced">Advanced</option>
            </param>
            <when value = "basic" />
            <when value= "advanced">
                <param type="data" argument="--contamination-fraction-per-sample-file" optional="true"/>
                <param type="boolean" argument="--adaptive-pruning" value="false" />
                <param type="boolean" argument="--all-site-pls" value="false" />
                <param type="boolean" argument="--allow-non-unique-kmers-in-ref" value="false" />
                <param type="boolean" argument="--debug-assembly" value="false" />
                <param type="boolean" argument="--disable-optimizations" value="false" />
                <param type="boolean" argument="--disable-tool-default-annotations" value="false" />
                <param type="boolean" argument="--do-not-run-physical-phasing" value="false" />
                <param type="boolean" argument="--dont-increase-kmer-sizes-for-cycles" value="false" />
                <param type="boolean" argument="--dont-trim-active-regions" value="false" />
                <param type="boolean" argument="--dont-use-soft-clipped-bases" value="false" />
                <param type="boolean" argument="--enable-all-annotations" value="false" />
                <param type="boolean" argument="--floor-blocks" value="false" />
                <param type="boolean" argument="--force-active" value="false" />
                <param type="boolean" argument="--force-call-filtered-alleles" value="false" />
                <param type="boolean" argument="--recover-all-dangling-branches" value="false" />
                <param type="boolean" argument="--use-filtered-reads-for-annotations" value="false" />
                <param type="integer" argument="--indel-size-to-eliminate-in-ref-model" value="10" />
                <param type="integer" argument="--assembly-region-padding" value="100" />
                <param type="integer" argument="--max-alternate-alleles" value="6" />
                <param type="integer" argument="--max-assembly-region-size" value="300" />
                <param type="integer" argument="--max-genotype-count" value="1024" />
                <param type="integer" argument="--max-mnp-distance" value="0" />
                <param type="integer" argument="--max-num-haplotypes-in-population" value="128"/>
                <param type="integer" argument="--max-prob-propagation-distance" value="50"/>
                <param type="integer" argument="--max-unpruned-variants" value="100"/>
                <param type="integer" argument="--min-assembly-region-size" value="50"/>
                <param type="integer" argument="--min-dangling-branch-length" value="4"/>
                <param type="integer" argument="--min-pruning" value="2"/>
                <param type="integer" argument="--num-pruning-samples" value="1"/>
                <param type="integer" argument="--pair-hmm-gap-continuation-penalty" value="10" />
                <param type="integer" argument="--phred-scaled-global-read-mismapping-rate" value="45" />
                <param type="float" argument="--pruning-lod-threshold" value="2.302585092994046" />
                <param type="float" argument="--active-probability-threshold" value="0.002" />
                <param type="float" argument="--adaptive-pruning-initial-error-rate" value="0.001" />
                <param type="text" argument="--kmer-size" value="[10, 25]" help="Enter list as if it were a Python list instantiation"/>
                <param type="text" argument="--gvcf-gq-bands" value="[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 70, 80, 90, 99]" help="Enter list as if it were a Python list instantiation" />
                <repeat argument="--input-prior" name="prior_repeat" label="Input prior for calls" help="By default, the prior specified with the argument --heterozygosity/-hets is used for variant discovery at a particular locus, using an infinite sites model.">
                    <param name="prior" label="Prior" type="float" optional="True"/>
                </repeat>  
                <repeat argument="--comparison" name="comparison_repeat" label="Comparison VCF files" help="If a call overlaps with a record from the provided comp track, the INFO field will be annotated as such in the output.">
                    <param name="vcf" label="Comparison File" type="data" format="vcf" optional="True"/>
                </repeat>  
                <param type="select" argument="--emit-ref-confidence" label="Mode for emitting reference confidence scores">
                    <option value="NONE" selected="True">NONE</option>
                    <option value="BP_RESOLUTION">BP_RESOLUTION</option>
                    <option value="GVCF">GVCF</option>
                </param>
                <param type="select" argument="--pair-hmm-implementation" label="Mode for emitting reference confidence scores">
                    <option value="FASTEST_AVAILABLE" selected="True">FASTEST_AVAILABLE</option>
                    <option value="ORIGINAL">ORIGINAL</option>
                    <option value="LOGLESS_CACHING">LOGLESS_CACHING</option>
                    <option value="AVX_LOGLESS_CACHING">AVX_LOGLESS_CACHING</option>
                    <option value="AVX_LOGLESS_CACHING_OMP">AVX_LOGLESS_CACHING_OMP</option>
                    <option value="EXPERIMENTAL_FPGA_LOGLESS_CACHING">EXPERIMENTAL_FPGA_LOGLESS_CACHING</option>
                </param>
                <param type="select" argument="--pcr-indel-model" label="PCR indel model">
                    <option value="CONSERVATIVE" selected="True">CONSERVATIVE</option>
                    <option value="AGGRESSIVE">AGGRESSIVE</option>
                    <option value="HOSTILE">HOSTILE</option>
                    <option value="NONE">NONE</option>
                </param>
                <param type="select" argument="--smith-waterman" label="Smith-Waterman implementation">
                    <option value="JAVA" selected="True">JAVA</option>
                    <option value="AVX_ENABLED">AVX_ENABLED</option>
                    <option value="FASTEST_AVAILABLE">FASTEST_AVAILABLE</option>
                </param>
            </when>
        </conditional>
        <!-- Omitted:
            -correct-overlapping-quality
            -dont-trim-active-regions 
        -->
    </inputs>
    <outputs>
        <data name="OUTPUT" type="data" format="vcf" label="GVCF file"/>
        <data name="ASSEMBLY_REGION_OUTPUT" type="data" format="tabular" label="Assembly Region Out">
            <filter>tool_params["tool_param_selector"] == "advanced" and tool_params["Outputs"]["assembly_region_out"]</filter>
        </data>
    </outputs>

    <tests>
    </tests>

    <help>
        **What it does**

        Apply base quality score recalibration
        This tool performs the second pass in a two-stage process called Base Quality Score Recalibration (BQSR). Specifically, it recalibrates the base qualities of the input reads based on the recalibration table produced by the BaseRecalibrator tool, and outputs a recalibrated BAM or CRAM file.

        https://gatk.broadinstitute.org/hc/en-us/articles/360037055712-ApplyBQSR

    </help>

</tool>