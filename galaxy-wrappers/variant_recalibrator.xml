<tool id="gatk4_VariantRecalibrator" name="GATK4 VariantRecalibrator" version="1.0.0">
    <description>- Build a recalibration model to score variant quality for filtering purposes</description>
    <macros>
      <import>macros.xml</import>
    </macros>
    <expand macro="requirements" />
    <command detect_errors="exit_code">
    <![CDATA[
        ##Fix to run on arm macbook
        export JAVA_HOME=/Users/benjaminbeer/Downloads/jdk-17.0.10.jdk/Contents/Home/bin &&
        export PATH=/Users/benjaminbeer/Downloads/jdk-17.0.10.jdk/Contents/Home/bin:\$PATH &&


        #if str($tool_params.tool_param_selector) == "advanced"
            #set $reference_provided = False
            #if str($FASTA_TYPE.FASTA_TYPE_SELECTOR) == "uploaded"
                #if str($FASTA) != "None":
                ln -s "$FASTA" fasta.fa &&
                #set $reference_provided = True
             #end if
            #else
                #set $fasta_file = $fasta_source.fasta_id.fields.path
                ln -s "$fasta_file" fasta.fa &&
                #set $reference_provided = True
            #end if
            #if $reference_provided
                samtools faidx fasta.fa &&
                gatk CreateSequenceDictionary -R fasta.fa -O fasta.dict &&
            #end if
        #end if

        #for $i, $file in enumerate($variant_repeat):
            bgzip -c ${file.VCF} > "${i}.gz" &&
            tabix -p vcf "${i}.gz" &&
        #end for

        #for $i, $resource in enumerate($resource_repeat):
            bgzip -c ${resource.GVCF} > reference_${i}.gz &&
            tabix -p vcf reference_${i}.gz &&
        #end for

        gatk VariantRecalibrator --output "$output1" --tranches-file "$output2"

        #for $i, $variant in enumerate($variant_repeat):
            --variant ${i}.gz
        #end for

        #for $i, $resource in enumerate($resource_repeat):
            --resource:${resource.type},known=${resource.known},training=${resource.training},truth=${resource.truth},prior=${resource.prior} reference_${i}.gz
        #end for

        #for $annotation in $annotations_repeat:
            -an ${annotation.A}
        #end for

        #if str($gatk_params.gatk_params_selector) == "advanced"
            ##Input Validation
            --read-validation-stringency "$read_validation_stringency"
            --disable-sequence-dictionary-validation "$disable_sequence_dictionary_validation"
            --lenient "$lenient"

            ##Genomic Intervals
            #for $i, $interval in enumerate($exclude_intervals_repeat):
                --exclude-intervals "${interval.XL}"
            #end for
            #if str($exclude_intervals_file) != "None"
                --exclude-intervals "$exclude_intervals_file"
            #end if
            --interval-exclusion-padding "$interval_exclusion_padding"
            --interval-set-rule "$interval_set_rule"

            ##Performance
            --use-jdk-deflater "$use_jdk_deflater"
            --use-jdk-inflater "$use_jdk_inflater"

            ##Macro Files
            #if str($gatk_config_file) != "None":
                --gatk-config-file "$gatk_config_file"
            #end if
            #if str($arguments_file) != "None":
                --arguments_file "$arguments_file"
            #end if
            #if str($sequence_dictionary) != "None":
                --sequence-dictionary "$sequence_dictionary"
            #end if
            #if str($read_index) != "None":
                --read-index "$read_index"
            #end if
        #end if

        #if str($tool_params.tool_param_selector) == "advanced"
            --mode "$mode"

            ##Inputs
            #if str($aggregate) != "None":
                --aggregate "$aggregate" 
            #end if
            #if $reference_provided
                --reference fasta.fa
            #end if
            #if str($input_model) != "None":
                --input-model "$input_model"
            #end if

            ##Input Validation
            --ignore-all-filters "$ignore_all_filters"

            ## Read Filters
            #for $filter in $tool_filters:
                --read-filter "$filter"
            #end for
            #if $AmbiguousBaseReadFilter:
                --read-filter "AmbiguousBaseReadFilter"
                #if $ambig_filter_frac
                    --ambig-filter-frac "$ambig_filter_frac"
                #else
                    --ambig-filter-bases "$ambig_filter_bases"
                #end if
            #end if
            #if $ExcessiveEndClippedReadFilter
                --read-filter "ExcessiveEndClippedReadFilter" 
                --max-clipped-bases "$max_clipped_bases"
            #end if
            #if $FlowBasedTPAttributeValidReadFilter
                --read-filter "FlowBasedTPAttributeValidReadFilter" 
                --read-filter-max-hmer "$read_filter_max_hmer"
            #end if
            #if $FragmentLengthReadFilter
                --read-filter "FragmentLengthReadFilter" 
                #if $max_fragment_length
                    --max-fragment-length "$max_fragment_length"
                #end if
                #if $min_fragment_length
                    --min-fragment-length "$min_fragment_length"
                #end if
            #end if
            #if $IntervalOverlapReadFilter
                --read-filter "IntervalOverlapReadFilter" 
                --keep-intervals "$keep_intervals"
            #end if
            #if $JexlExpressionReadTagValueFilter
                --read-filter "JexlExpressionReadTagValueFilter" 
                --read-filter-expression "$read_filter_expression"
            #end if
            #if $LibraryReadFilter
                --read-filter "LibraryReadFilter" 
                --library "$library"
            #end if
            #if $MappingQualityReadFilter
                --read-filter "MappingQualityReadFilter" 
                #if $minimum_mapping_quality
                    --minimum-mapping-quality "$minimum_mapping_quality"
                #end if
                #if $maximum_mapping_quality
                    --maximum-mapping-quality "$maximum_mapping_quality"
                #end if
            #end if
            #if $MateDistantReadFilter
                --read-filter "MateDistantReadFilter" 
                --mate-too-distant-length "$mate_too_distant_length"
            #end if
            #if $OverclippedReadFilter
                --read-filter "OverclippedReadFilter" 
                --filter-too-short "$filter_too_short"
                --dont-require-soft-clips-both-ends "$dont_require_soft_clips_both_ends"
            #end if
            #if $PlatformReadFilter
                --read-filter "PlatformReadFilter" 
                --platform-filter-name "$platform_filter_name"
            #end if
            #if $PlatformUnitReadFilter
                --read-filter "PlatformUnitReadFilter" 
                --black-listed-lanes "$black_listed_lanes"
            #end if
            #if $ReadGroupBlackListReadFilter
                --read-filter "ReadGroupBlackListReadFilter" 
                --read-group-black-list "$read_group_black_list"
            #end if
            #if $ReadGroupReadFilter
                --read-filter "ReadGroupReadFilter" 
                --keep-read-group "$keep_read_group"
            #end if
            #if $ReadLengthReadFilter
                --read-filter "ReadLengthReadFilter" 
                --max-read-length "$max_read_length"
                #if $min_read_length
                    --min-read-length "$min_read_length"
                #end if
            #end if
            #if $ReadNameReadFilter
                --read-filter "ReadNameReadFilter" 
                --read-name "$read_name"
            #end if
            #if $ReadStrandFilter
                --read-filter "ReadStrandFilter" 
                --keep-reverse-strand-only "$keep_reverse_strand_only"
            #end if
            #if $ReadTagValueFilter
                --read-filter "ReadTagValueFilter" 
                --read-filter-tag "$read_filter_tag"
                --read-filter-tag-comp "$read_filter_tag_comp"
            #end if
            #if $SampleReadFilter
                --read-filter "SampleReadFilter" 
                --sample "$sample"
            #end if
            #if $SoftClippedReadFilter:
                --read-filter "SoftClippedReadFilter"
                --invert-soft-clip-ratio-filter "$invert_soft_clip_ratio_filter"
                #if $soft_clipped_ratio_threshold
                    --soft-clipped-ratio-threshold "$soft_clipped_ratio_threshold"
                #else
                    --soft-clipped-leading-trailing-ratio "$soft_clipped_leading_trailing_ratio"
                #end if
            #end if
            --disable-tool-default-read-filters "$disable_tool_default_read_filters"

            ##Statistics Constants
            --target-titv "$target_titv"
            --bad-lod-score-cutoff "$bad_lod_score_cutoff"
            --dirichlet "$dirichlet"
            --prior-counts "$prior_counts"
            --shrinkage "$shrinkage"
            --standard-deviation-threshold "$standard_deviation_threshold"
            --k-means-iterations "$k_means_iterations"
            --max-attempts "$max_attempts"
            --max-gaussians "$max_gaussians"
            --max-negative-gaussians "$max_negative_gaussians"
            --max-iterations "$max_iterations"
            --maximum-training-variants "$maximum_training_variants"
            --minimum-bad-variants "$minimum_bad_variants"
            --mq-cap-for-logit-jitter-transform "$mq_cap_for_logit_jitter_transform"
            #set $tranche_list = $truth_sensitivity_tranche.replace("[", "").replace("]", "").replace(" ", "").split(",")
            #for $number in $tranche_list:
                 --truth-sensitivity-tranche "$number"
            #end for
            --use-allele-specific-annotations "$use_allele_specific_annotations"
            --trust-all-polymorphic "$trust_all_polymorphic"

            ##Genomic Intervals
            #for $i, $interval in enumerate($intervals_repeat):
                --intervals "${interval.L}"
            #end for
            --interval-padding "$interval_padding"
            --interval-merging-rule "$interval_merging_rule"

            ##Penalties & Buffers
            --cloud-prefetch-buffer "$cloud_prefetch_buffer"
            #if $cloud_index_prefetch_buffer
                --cloud-index-prefetch-buffer "$cloud_index_prefetch_buffer"
            #end if

            ##Performance
            --gcs-max-retries "$gcs_max_retries"
            --disable-bam-index-caching "$disable_bam_index_caching"
            #if $gcs_project_for_requester_pays != "":
                --gcs-project-for-requester-pays "$gcs_project_for_requester_pays"
            #end if

            ##Outputs
            #if $rscript_file
                --rscript-file "$output3"
            #end if
            #if $output_model
                --output-model "$output4"
            #end if
            --sites-only-vcf-output "$sites_only_vcf_output"
        #end if
    ]]>
    </command>
    <inputs>
        <repeat argument="--variant" name="variant_repeat" title="Variant files" help="A VCF file containing variants" default="1" >
            <param name="VCF" type="data" format="vcf" />
        </repeat>
        <repeat argument="--resource" name="resource_repeat" title="Resource Sequences" help="" default="1">
            <param type="select" name="type" label="Resource Sequence" >
                <option value="hapmap">hapmap</option>
                <option value="omni">omni</option>
                <option value="1000G">1000G</option>
                <option value="dbsnp">dbsnp</option>
            </param>
            <param type="boolean" name="known" label="Known" checked="False" />
            <param type="boolean" name="training" label="Training" checked="False" />
            <param type="boolean" name="truth" label="Truth" checked="False" />
            <param type="float" name="prior" label="Prior" />
            <param name="GVCF" type="data" format="vcf" />
        </repeat>    
        <repeat argument="--annotations" name="annotations_repeat" title="Annotations to add to variant calls" help="" default="1">
            <param name="A" type="text" value="" />
        </repeat>  

        <expand macro="gatk_param_type_conditional" />

        <conditional name ="tool_params">
            <param name="tool_param_selector" type="select" label="Basic or Advanced Tool options">
            <option value="basic" selected="True">Basic</option>
            <option value="advanced">Advanced</option>
            </param>
            <when value="basic">
            <!--Do nothing-->
            </when>
            <when value="advanced">
                <param type="select" argument="--mode" label="Recalibration mode">
                    <option value="SNP" selected="True">SNP</option>
                    <option value="INDEL">INDEL</option>
                    <option value="BOTH">BOTH</option>
                </param>
                <section name="Inputs">
                <!-- Find format -->
                    <param type="data" format="vcf" argument="--aggregate" label="Additional raw input variants" optional="True" />
                    <conditional name="FASTA_TYPE">
                        <param name="FASTA_TYPE_SELECTOR" type="select" label="Reference File" >
                            <option value="uploaded" selected="True">Uploaded</option>
                            <option value="galaxy">Galaxy</option>
                        </param>
                        <when value="uploaded">
                            <param type="data" argument="--reference" name="FASTA" format="fasta" label="Reference file" optional="true" />
                        </when>
                        <when value="galaxy">
                        <param argument="--reference" type="select" label="Select reference genome" help="If your genome of interest is not listed, contact the Galaxy team" optional="True">
                            <options from_data_table="fasta_indexes" />
                        </param>
                        </when>
                    </conditional>
                    <!-- Find format -->
                    <param type="data" argument="--input-model" label="VQSR to recalibrate input variants" help="This model should be generated using a previous VariantRecalibration run with the --output-model argument." optional="True" />
                </section>
                <section name="Input Validation">
                    <param type="boolean" argument="--ignore-all-filters" label="Ignore all input filters" checked="False" />
                </section>
                <section name="Read Filters" help="Filters to apply in addition to tool-defaults">
                    <param name="tool_filters" type="select" multiple="True" display="checkboxes" label="Default read filters"  >
                        <option value="AlignmentAgreesWithHeaderReadFilter" selected="False" />
                        <option value="AllowAllReadsReadFilter" selected="False" />
                        <option value="CigarContainsNoNOperator" selected="False" />
                        <option value="FirstOfPairReadFilter" selected="False" />
                        <option value="FlowBasedTPAttributeSymetricReadFilter" selected="False" />
                        <option value="GoodCigarReadFilter" selected="False" />
                        <option value="HasReadGroupReadFilter" selected="False" />
                        <option value="HmerQualitySymetricReadFilter" selected="False" />
                        <option value="MappedReadFilter" selected="False" />
                        <option value="MappingQualityAvailableReadFilter" selected="False" />
                        <option value="MappingQualityNotZeroReadFilter" selected="False" />
                        <option value="MatchingBasesAndQualsReadFilter" selected="False" />
                        <option value="MateDifferentStrandReadFilter" selected="False" />
                        <option value="MateOnSameContigOrNoMappedMateReadFilter" selected="False" />   
                        <option value="MateUnmappedAndUnmappedReadFilter" selected="False" />
                        <option value="MetricsReadFilter" selected="False" />
                        <option value="NonChimericOriginalAlignmentReadFilter" selected="False" />
                        <option value="NonZeroFragmentLengthReadFilter" selected="False" />
                        <option value="NonZeroReferenceLengthAlignmentReadFilter" selected="False" />
                        <option value="NotDuplicateReadFilter" selected="False" />
                        <option value="NotProperlyPairedReadFilter" selected="False" />
                        <option value="NotSecondaryAlignmentReadFilter" selected="False" />   
                        <option value="NotSupplementaryAlignmentReadFilter" selected="False" />
                        <option value="PairedReadFilter" selected="False" />
                        <option value="PassesVendorQualityCheckReadFilter" selected="False" />
                        <option value="PrimaryLineReadFilter" selected="False" />
                        <option value="ProperlyPairedReadFilter" selected="False" />   
                        <option value="ReadGroupHasFlowOrderReadFilter" selected="False" />
                        <option value="ReadLengthEqualsCigarLengthReadFilter" selected="False" />
                        <option value="SecondOfPairReadFilter" selected="False" />
                        <option value="SeqIsStoredReadFilter" selected="False" />
                        <option value="ValidAlignmentEndReadFilter" selected="False" />
                        <option value="ValidAlignmentStartReadFilter" selected="False" />
                        <option value="WellformedFlowBasedReadFilter" selected="False" />
                        <option value="WellformedReadFilter" selected="False" />   
                    </param>
                    <conditional name="AmbiguousBaseReadFilter">
                        <param type="boolean" name="AmbiguousBaseReadFilter" truevalue="Yes" falsevalue="No" label="Ambiguous Base Read Filter" />
                        <when value="Yes">
                            <param type="float" argument="--ambig-filter-frac" value="0.5" optional="True"/>
                            <param type="integer" argument="--ambig-filter-bases" optional="True"/>
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="ExcessiveEndClippedReadFilter">
                        <param type="boolean" name="ExcessiveEndClippedReadFilter" truevalue="Yes" falsevalue="No" label="Excessive End Clipped Read Filter" />
                        <when value="Yes">
                            <param type="integer" argument="--max-clipped-bases" value="1000" />
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="FlowBasedTPAttributeValidReadFilter">
                        <param type="boolean" name="FlowBasedTPAttributeValidReadFilter" truevalue="Yes" falsevalue="No" label="Flow Based TP Attribute Valid Read Filter" />
                        <when value="Yes">
                            <param type="integer" argument="--read-filter-max-hmer" value="12" />
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="FragmentLengthReadFilter">
                        <param type="boolean" name="FragmentLengthReadFilter" truevalue="Yes" falsevalue="No" label="Fragment Length Read Filter" />
                        <when value="Yes">
                            <param type="integer" argument="--max-fragment-length" value="1000000" />
                            <param type="integer" argument="--min-fragment-length" value="0" />
                        </when>
                        <when value="No" />
                    </conditional>
                    <conditional name="IntervalOverlapReadFilter">
                        <param type="boolean" name="IntervalOverlapReadFilter" truevalue="Yes" falsevalue="No" label="Interval Overlap Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--keep-intervals" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="JexlExpressionReadTagValueFilter">
                        <param type="boolean" name="JexlExpressionReadTagValueFilter" truevalue="Yes" falsevalue="No" label="Jexl Expression Read Tag Value Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-filter-expression" help="One or more JEXL expressions used to filter"/>
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="LibraryReadFilter">
                        <param type="boolean" name="LibraryReadFilter" truevalue="Yes" falsevalue="No" label="Library Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--library" help="Name of the library to keep"/>
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="MappingQualityReadFilter">
                        <param type="boolean" name="MappingQualityReadFilter" truevalue="Yes" falsevalue="No" label="Mapping Quality Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--minimum-mapping-quality" value="10" optional="True" />
                                <param type="integer" argument="--maximum-mapping-quality" optional="True" />                            
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="MateDistantReadFilter">
                        <param type="boolean" name="MateDistantReadFilter" truevalue="Yes" falsevalue="No" label="Mate Distant Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--mate-too-distant-length" value="1000" />                    
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="OverclippedReadFilter">
                        <param type="boolean" name="OverclippedReadFilter" truevalue="Yes" falsevalue="No" label="Overclipped Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--filter-too-short" value="30" />   
                                <param type="boolean" argument="--dont-require-soft-clips-both-ends" checked="False" />                 
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="PlatformReadFilter">
                        <param type="boolean" name="PlatformReadFilter" truevalue="Yes" falsevalue="No" label="Platform Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--platform-filter-name" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="PlatformUnitReadFilter">
                        <param type="boolean" name="PlatformUnitReadFilter" truevalue="Yes" falsevalue="No" label="Platform Unit Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--black-listed-lanes" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadGroupBlackListReadFilter">
                        <param type="boolean" name="ReadGroupBlackListReadFilter" truevalue="Yes" falsevalue="No" label="Read Group BlackList Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-group-black-list" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadGroupReadFilter">
                        <param type="boolean" name="ReadGroupReadFilter" truevalue="Yes" falsevalue="No" label="Read Group Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--keep-read-group" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadLengthReadFilter">
                        <param type="boolean" name="ReadLengthReadFilter" truevalue="Yes" falsevalue="No" label="Read Length Read Filter" />
                            <when value="Yes">
                                <param type="integer" argument="--max-read-length" />  
                                <param type="integer" argument="--min-read-length" value="1" optional="True" />                          
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadNameReadFilter">
                        <param type="boolean" name="ReadNameReadFilter" truevalue="Yes" falsevalue="No" label="Read Name Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-name" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadStrandFilter">
                        <param type="boolean" name="ReadStrandFilter" truevalue="Yes" falsevalue="No" label="Read Strand Filter" />
                            <when value="Yes">
                                <param type="boolean" argument="--keep-reverse-strand-only" checked="False" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="ReadTagValueFilter">
                        <param type="boolean" name="ReadTagValueFilter" truevalue="Yes" falsevalue="No" label="Read Tag Value Filter" />
                            <when value="Yes">
                                <param type="text" argument="--read-filter-tag" />
                                <param type="float" argument="--read-filter-tag-comp" value="0.0" />
                                <param type="select" argument="--read-filter-tag-op" label="Read Filter Tag Operator">
                                    <option value="EQUAL" selected="True">EQUAL</option>
                                    <option value="NOT_EQUAL">NOT_EQUAL</option>
                                    <option value="LESS">LESS</option>
                                    <option value="LESS_OR_EQUAL">LESS_OR_EQUAL</option>
                                    <option value="GREATER">GREATER</option>
                                    <option value="GREATER_OR_EQUAL">GREATER_OR_EQUAL</option>
                                </param>
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="SampleReadFilter">
                        <param type="boolean" name="SampleReadFilter" truevalue="Yes" falsevalue="No" label="Sample Read Filter" />
                            <when value="Yes">
                                <param type="text" argument="--sample" />
                            </when>
                            <when value="No" />
                    </conditional>
                    <conditional name="SoftClippedReadFilter">
                        <param type="boolean" name="SoftClippedReadFilter" truevalue="Yes" falsevalue="No" label="Soft ClippedRead Filter" />
                            <when value="Yes">
                                <param type="boolean" argument="--invert-soft-clip-ratio-filter" checked="False" />
                                <param type="float" argument="--soft-clipped-ratio-threshold" optional="True" />
                                <param type="float" argument="--soft-clipped-leading-trailing-ratio" optional="True" />                            
                            </when>
                            <when value="No" />
                    </conditional>
                    <param type="boolean" argument="--disable-tool-default-read-filters" checked="False" />
                </section>
                <section name="Statistics Constants">
                    <param type="float" argument="--target-titv" label="Expected Ti/Tv ratio" value="2.15" help="For calculating FDR tranches and optimization curve output figures" />
                    <param type="float" argument="--bad-lod-score-cutoff" label="LOD score cutoff for bad variants" value="5.0" />
                    <param type="float" argument="--dirichlet" label="Dirichlet parameter for Bayes algorism" value="0.001" />
                    <param type="float" argument="--prior-counts" label="Number of prior counts in variational Bayes algorithm" value="20.0" />
                    <param type="float" argument="--shrinkage" label="Shrinkage parameter in Bayes algorithm" value="1.0" />
                    <param type="float" argument="--standard-deviation-threshold" label="Annotation value divergence threshold" value="10.0" />
                    <param type="integer" argument="--k-means-iterations" label="Number of k-means iterations" value="100" />
                    <param type="integer" argument="--max-attempts" label="Number of attempts to build model before failing" value="1" help="The first successfully built model will be kept" />
                    <param type="integer" argument="--max-gaussians" label="Max number of Gaussians for positive model" value="8" help="For the variational Bayes algorithm" />
                    <param type="integer" argument="--max-negative-gaussians" label="Max number of Gaussians for negative model" value="2" help="For the variational Bayes algorithm" />
                    <param type="integer" argument="--max-iterations" label="Max number of VBEM iterations" value="150" help="Usually ends when convergence is detected" />
                    <param type="integer" argument="--maximum-training-variants" label="Maximum number of training variants" value="2500000" help="Training sets larger than this will be downsampled randomly" />
                    <param type="integer" argument="--minimum-bad-variants" label="Min number of bad variants" value="1000" help="Minimum number of worst scoring variants for Gaussian mixture model" />
                    <param type="integer" argument="--mq-cap-for-logit-jitter-transform" label="Apply logit transform and jitter to MQ values" value="0" help="MQ is capped at a max value (60 for bwa-mem) when the alignment is considered perfect." />
                    <param type="text" argument="--truth-sensitivity-tranche" label="Levels of truth sensitivity for slicing data" value="[100.0, 99.9, 99.0, 90.0]" />
                    <param type="boolean" argument="--use-allele-specific-annotations" label="Attempt to use the allele-specific versions of the specified annotations" checked="False" />
                    <param type="boolean" argument="--trust-all-polymorphic" label="Trust that training sets only contain polymorphic sites" checked="False" help="Enabling greatly speeds up computation" />
                </section>
                <section name="Genomic Intervals">
                    <repeat argument="--intervals" name="intervals_repeat" title="Genomic interval over which to operate" help="-L">
                        <param name="L" type="text" value="" />
                    </repeat>
                    <param type="integer" argument="--interval-padding" label="Amount of padding for each interval (bp)" value="0" help="For example, '-L 1:100' with a padding value of 20 would turn into '-L 1:80-120'."/>
                    <param type="select" argument="--interval-merging-rule" label="Rule for merging abutting intervals">
                        <option value="ALL" selected="True">ALL</option>
                        <option value="OVERLAPPING_ONLY">OVERLAPPING_ONLY</option>
                    </param>
                </section>
                <section name="Penalties &amp; Buffers">
                    <param type="integer" argument="--cloud-prefetch-buffer" label="Size of the cloud-only prefetch buffer (in MB)" value="40" help="0 to disable." />
                    <param type="integer" argument="--cloud-index-prefetch-buffer" label="Size of the cloud-only prefetch buffer (in MB)" optional="True" help="Defaults to cloudPrefetchBuffer" />
                </section>
                <section name="Performance">
                    <param type="integer" argument="--gcs-max-retries" label="Number of times to attempt to re-initiate connection to GCS bucket channel" value="20" />
                    <param type="boolean" argument="--disable-bam-index-caching" label="Cache bam indexes (reduces memory requirements)" checked="True" />
                    <param type="text" argument="--gcs-project-for-requester-pays" optional="true" help="If unset, these buckets cannot be accessed." />
                </section>
                <section name="Outputs">
                    <param type="boolean" argument="--rscript-file" label="Output Rscript file generated to visualize input data and learned model" checked="False" />
                    <param type="boolean" argument="--output-model" label="Output VQSR model" checked="False" />
                    <param type="boolean" argument="--sites-only-vcf-output" label="Emit genotype fields when writing vcf file output." checked="False" />
                </section>
            </when>
        </conditional>

    </inputs>
    <outputs>
        <data argument="--output" name="output1" type="data" format="vcf" label="Recalibration Output" />
        <data argument="--tranches" name="output2" type="data" format="tranches" label="Tranches Output"/>
        <data argument="--rscript-file" name="output3" type="data" label="Plots Script">
            <filter>tool_params['tool_param_selector'] == 'advanced' and tool_params['Outputs']['rscript_file']</filter>
        </data>
        <data argument="VQSR_model" name="output4" type="data" label="VQSR Model">
            <filter>tool_params['tool_param_selector'] == 'advanced' and tool_params['Outputs']['output_model']</filter>
        </data>
    </outputs>

    <tests>
    </tests>

    <help>
      **What it does**

      Build a recalibration model to score variant quality for filtering purposes
      This tool performs the first pass in a two-stage process called Variant Quality Score Recalibration (VQSR). Specifically, it builds the model that will be used in the second step to actually filter variants. This model attempts to describe the relationship between variant annotations (such as QD, MQ and ReadPosRankSum, for example) and the probability that a variant is a true genetic variant versus a sequencing or data processing artifact. It is developed adaptively based on "true sites" provided as input, typically HapMap sites and those sites found to be polymorphic on the Omni 2.5M SNP chip array (in humans). This adaptive error model can then be applied to both known and novel variation discovered in the call set of interest to evaluate the probability that each call is real. The result is a score called the VQSLOD that gets added to the INFO field of each variant. This score is the log odds of being a true variant versus being false under the trained Gaussian mixture model.

      https://gatk.broadinstitute.org/hc/en-us/articles/5358906115227-VariantRecalibrator

    </help>
</tool>